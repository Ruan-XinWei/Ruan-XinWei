{"pages":[],"posts":[{"title":"算法笔记","text":"记参加CCCC和蓝桥杯学习到的算法知识 一些基础库setset（集合）在算法中主要起到的作用是元素不重复，还能够快速得到集合的大小以及集合的一些操作，例如交集，并集，差集.. 简单的set操作 123456789101112#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; s; s.insert(1); // 插入元素 cout &lt;&lt; s.size() &lt;&lt; endl; // 获取集合大小 return 0;} 交集，并集，差集 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;//求两个集合的和(并集)、差、交集//set库提供set容器，iterator库提供迭代器，algorithm库提供集合操作(故也可以对其他容器进行集合操作)int main(){ set&lt;int&gt; a, b; set&lt;int&gt; c, d, e; a.insert(1); a.insert(2); b.insert(2); b.insert(3); // 并集 set_union(a.begin(), a.end(), b.begin(), b.end(), insert_iterator&lt;set&lt;int&gt;&gt;(c, c.begin())); // 差集 set_difference(a.begin(), a.end(), b.begin(), b.end(), insert_iterator&lt;set&lt;int&gt;&gt;(d,d.begin())); // 交集 set_intersection(a.begin(), a.end(), b.begin(), b.end(), insert_iterator&lt;set&lt;int&gt;&gt;(e, e.begin())); return 0;}","link":"/2021/04/04/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"前端学习笔记","text":"人生就是一种平衡简简单单才是真，平平淡淡才是福人之所以痛苦，就在于追求了过多不属于自己的东西懂得知足的人，即使粗茶淡饭，也能够尝出人生的美味与其在遗憾中郁郁寡欢，不如好好珍惜自己的拥有，这样才能收获更多的快乐 Front-End-LearningHTML5介绍css修饰过的html标签123456789101112&lt;head&gt; h1{ font-size: 12px; color: #930; text-align: center; }&lt;/head&gt;&lt;body&gt; &lt;h1&gt; Hello World! &lt;/h1&gt;&lt;/body&gt; HTML5文档结构12345678910&lt;!DOCTYPE html&gt; &lt;!--声明文档结构为html5--&gt;&lt;html&gt; &lt;!--html标签为html文件的根标签--&gt; &lt;head&gt; &lt;!--head标签为头部标签，一般存放meta和title标签等--&gt; &lt;meta charset = \"UTF-8\"&gt; &lt;!--声明当前文档字符集编码为UTF-8--&gt; &lt;title&gt;HTML5文档结构&lt;/title&gt; &lt;!--title标签设置为浏览器标题--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--body标签为网页内容--&gt; &lt;/body&gt;&lt;/html&gt; HTML5注释1&lt;!--这里是注释--&gt; HTML5 语义化标签段落标签1&lt;p&gt;段落文本&lt;/p&gt; &lt;p&gt;标签的默认格式：在段前段后都会有空白，可以使用css样式来改变。 自定义文本样式&lt;span&gt;文本&lt;/span&gt; 然后在 span{ coror:blue; } 文章标题12345678&lt;body&gt; &lt;h1&gt;一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h3&gt;三级标题&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;h5&gt;五级标题&lt;/h5&gt; &lt;h6&gt;六级标题&lt;/h6&gt;&lt;/body&gt; 标题标签一共有6个：h1，h2，h3，h4，h5，h6。 标题组1234&lt;hgroup&gt; &lt;h1&gt;题目&lt;/h1&gt; &lt;h2&gt;作者&lt;/h2&gt;&lt;/hgroup&gt; 语调强调1&lt;em&gt;语调强调&lt;/em&gt; 语义强调1&lt;strong&gt;语义强调&lt;/strong&gt; 长引用123&lt;blockquote&gt; 长引用&lt;/blockquote&gt; 短引用1&lt;q&gt;短引用&lt;/q&gt; 自定义块1&lt;div&gt;...&lt;/div&gt; 相当于独立板块，容器。 标签定义头部区域1&lt;header&gt;头部标签&lt;/header&gt; 标签定义主要区域12&lt;!-- 只能有一个 --&gt;&lt;main&gt;主要标签&lt;/main&gt; 标签定义底部区域1&lt;footer&gt;底部标签&lt;/footer&gt; 定义区段1&lt;section&gt;区域&lt;/section&gt; 侧边栏1&lt;aside&gt;侧边栏&lt;/aside&gt; 导航1&lt;nav&gt;&lt;/nav&gt; 文章1&lt;article&gt;&lt;/article&gt; HTML5效果标签换行效果1&lt;br/&gt; 在换行的地方添加&lt;br/&gt;。 注意：&lt;br/&gt;是空标签，只需要写一个开始标签，类似的有&lt;hr/&gt;和&lt;img/&gt;。 空格效果1&amp;nbsp; 使用特殊字符&amp;nbsp;来表示空格。 水平分割线效果1&lt;hr/&gt; 使用&lt;hr/&gt;来实现水平分割线效果 HTML5列表标签无序列表1234&lt;ul&gt; &lt;li&gt;第一个无序列表&lt;/li&gt; &lt;li&gt;第二个无序列表&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;第一个有序列表&lt;/li&gt; &lt;li&gt;第二个有序列表&lt;/li&gt;&lt;/ol&gt; 定义列表1234&lt;dl&gt; &lt;dt&gt;列标题&lt;/dt&gt; &lt;dd&gt;解释&lt;/dd&gt;&lt;/dl&gt; HTML5图片，链接及表格标签图片标签1&lt;img src = \"图片地址\" alt = \"下载失败时的替换文本\" title = \"提示文本\" width=\"宽度像素\" height=\"高度像素\"&gt; 图片格式 jpeg（jpg） 支持颜色比较丰富，不支持透明效果，不支持动图 一般用来显示图片 gif 支持的颜色比较少，支持简单透明，支持动图 一般用来显示简单单一的图片，动图 png 支持的颜色丰富，支持复杂透明，不支持动图 颜色丰富，复杂透明图片 webp 谷歌推出专门用来表示网页图片的一种格式 兼容其他图片的所有优点，而且文件特别小 缺点：兼容性不好 base64 将文件使用base64编码，通过字符来引入图片 主要用于需要和网页一起加载的图片 选用图片格式的标准 效果一样，用小的 效果不同，用好的 超链接标签1&lt;a href = \"目标网址\" title = \"提示文本\"&gt;链接显示文本&lt;/a&gt; 相对路径 ./：表示当前文件的目录； ../：表示当前文件的上一级目录； 如果不存在，则默认为./。 跳转当前页面指定位置12&lt;a href=\"#\"&gt;跳转到顶部&lt;/a&gt;&lt;a href=\"#idposition\"&gt;跳转到id属性为idposition的位置&lt;/a&gt; 超链接占位符1&lt;a href=\"javascript:;\"&gt;超链接占位符&lt;/a&gt; 新窗口或原窗口打开超链接1234&lt;!--在当前页面打开超链接--&gt;&lt;a href = \"目标网址\" target = \"_self\"&gt;链接提示文本&lt;/a&gt;&lt;!--在新页面打开超链接--&gt;&lt;a href = \"目标网址\" target = \"_blank\"&gt;链接提示文本&lt;/a&gt; 生成一段英文文本使用lorem 表格标签123456789101112131415&lt;!--border属性为表格添加边框--&gt;&lt;table border = \"1\"&gt; &lt;!--表格标题--&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表示每一行使用&lt;tr&gt;--&gt; &lt;tr&gt; &lt;!--默认加粗并居中--&gt; &lt;th&gt;表格第一列的标题&lt;/th&gt; &lt;th&gt;表格第二列的标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格第二行第一列内容&lt;/td&gt; &lt;td&gt;表格第二行第二列内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 使用thead、tbody、tfoot定义表格123456789101112131415161718192021222324252627&lt;!--border属性为表格添加边框--&gt;&lt;table border = \"1\"&gt; &lt;!--表格标题--&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表头--&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--默认加粗并居中--&gt; &lt;th&gt;表头第一列的标题&lt;/th&gt; &lt;th&gt;表头第二列的标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--表身--&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表身第一行第一列内容&lt;/td&gt; &lt;td&gt;表身第一行第二列内容&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!--表尾--&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;表尾第一行第一列内容&lt;/td&gt; &lt;td&gt;表尾第一行第二列内容&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; HTML5内联框架、音视频标签内联框架12&lt;!-- frameborder=\"0\"代表没有边框 frameborder=\"1\"代表有边框 --&gt;&lt;iframe src=\"引入的地址\" weight=\"宽度\" height=\"高度\" frameborder=\"0\"&gt;&lt;/iframe&gt; 音频标签12345678910111213&lt;!-- controls 是否允许用户控制播放 autoplay 音频文件是否自动播放，但大多数浏览器不会自动播放 loop 音频是否循环播放 --&gt;&lt;audio src=\"音频地址\" controls autoplay loop&gt;&lt;/audio&gt;&lt;!-- 使用source指定文件位置 --&gt;&lt;audio controls&gt; &lt;source src=\"./xxx.mp3\"&gt; &lt;source src=\"./xxx.ogg\"&gt; &lt;embed src=\"./xxx.mp3\" type=\"audio/mp3\" width=\"400\" height=\"300\"&gt;&lt;/audio&gt; 视频标签12345678910111213141516&lt;!-- controls 是否允许用户控制播放 autoplay 视频文件是否自动播放，但大多数浏览器不会自动播放 loop 视频是否循环播放 --&gt;&lt;!-- 用法和audio基本一样 --&gt;&lt;!-- 使用source指定文件位置 --&gt;&lt;video controls&gt; &lt;source src=\"./xxx.webm\"&gt; &lt;source src=\"./xxx.mp4\"&gt; &lt;embed src=\"./xxx.mp4\" type=\"video/mp4\"&gt;&lt;/video&gt;&lt;!-- 还可以通过其他视频网站的视频分享进网页中 --&gt; HTML5表单标签创建表单123&lt;form method = \"传送方式\" action = \"服务器文件\"&gt; ...&lt;/form&gt; &lt;form&gt;：创建表单标签； method：数据传送方式（get / post）； action：输入的数据传送的地方，例如”save.php”。 文本输入框、密码输入框1234&lt;form&gt; &lt;input type = \"text\" name = \"text\" value = \"text\"&gt; &lt;input type = \"password\" name = \"password\" value = \"password\"&gt;&lt;/form&gt; type： 当type = “text”时，输入框为文本输入框； 当type = “password”时，输入框为密码输入框。 name：文本框变量名。 value：文本框默认值。 placehorder属性12&lt;input type = \"text\" placehorder = \"请输入用户名\"&gt;&lt;input type = \"password\" placehorder = \"请输入密码\"&gt; placehorder属性为输入框占位符，里面放文本框提示信息； 当输入框内容为空提示信息才显示，当输入框内容不为空提示信息消失； placehorder的内容不是输入框中真正的内容。 数字输入框1&lt;input type = \"number\"&gt; 输入框只能输入数字； 输入框右侧有加减符号，可以调整数字大小。 网址输入框1&lt;input type = \"url\"&gt; 网址输入框的值需要以http://或者https://开头，并且后面必须有内容，否则表单提交时会报错提示。 邮箱输入框1&lt;input type = \"email\"&gt; 邮箱输入框中的值必须包含@，并且之后必须要有内容，否则表单提交时会有报错提示。 文本域1&lt;textarea cols = \"50\" rows = \"10\"&gt;在这里输入内容&lt;/textarea&gt; cols：输入域的列数； rows：输入域的行数； &lt;textarea&gt;和&lt;/textarea&gt;之间可以输入默认值。 laber标签1234&lt;form &lt;label for = \"email\"&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type = \"email\" id = \"email\" placeholder = \"Enter email\"&gt;&lt;/form&gt; laber标签中for属性的值必须与相关的控件id值相同 单选框、复选框1&lt;input type = \"radio/checkbox\" value = \"值\" name = \"名称\" checked = \"checked\"&gt; type： 当type = “radio”时，控件为单选框；特别注意：对于同一组选项，name值必须相同，才能做到单选的效果 当type = “checkbox”时，控件为多选框。 value：提交数据到服务器的值（后台程序PHP使用。 name：为控件命名，以备后台程序 ASP、PHP 使用。 checked：当设置 checked=”checked” 时，该选项被默认选中。 下拉菜单12345678&lt;form&gt; &lt;select&gt; &lt;option value=\"看书\"&gt;看书&lt;/option&gt; &lt;option value=\"运动\"&gt;运动&lt;/option&gt; &lt;option value=\"购物\"&gt;购物&lt;/option&gt; &lt;option value=\"旅游\" selected = \"selected\"&gt;旅游&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; select和option标签都是双标签，它总是成对出现的，需要首标签和尾标签； select标签里面只能放option标签，表示下拉列表的选项； option： 标签放选项内容，不放置其他标签； 标签之间为显示选项的内容。 value：向服务器提交的值； selected：设置selected=”selected”属性，则该选项就被默认选中。 提交按钮、重置按钮12&lt;input type=\"submit\" value=\"提交\" name=\"submitBtn\"&gt;&lt;input type=\"reset\" value=\"重置\" name=\"resetBtn\"&gt; type： 当type = “submit”时，为提交按钮； 当type = “reset”时，为重置按钮。 value：按钮上的值； name：按钮控件名。 CSS3介绍认识CSS样式12345p{ font-size: 12px; color: red; font-weight: bold;} 使用CSS样式的一个好处是通过定义某个样式，可以让不同网页位置的文字有着统一的字体、字号或者颜色等。 短语样式123span{ color: red;} 使用&lt;span&gt;和&lt;/span&gt;括起短语实现样式修改。 CSS代码语法1p{ color: blue; } p是选择符；又称选择器，指明网页中要应用样式规则的元素。 color是属性； blue是值； “{ }”中的就是声明；属性和值之间用:分隔，多条声明用;分隔。 一般为了便于阅读，每一条声明都占一行。 CSS注释代码1/*这里是注释*/ CSS样式代码插入形式-内联式1&lt;p style = \"color: red\"&gt;这里的文字是红色&lt;/p&gt; 多条css样式则用;隔开。 CSS样式代码插入形式-嵌入式12345&lt;style type = \"text/css\"&gt;span{ color: red;}&lt;/style&gt; 嵌入式css样式必须写在&lt;style&gt;和&lt;/style&gt;之间，并且一般情况下，嵌入式css样式写在&lt;head&gt;和&lt;/head&gt;之间。 CSS样式代码插入形式-外部式12345/*style.css*/span{ color: blue; font-size: 20px;} 1234&lt;!--index.html--&gt;&lt;head&gt; &lt;link href = \"style.css\" rel = \"stylesheet\" type = \"text/css\" /&gt;&lt;/head&gt; 将css代码写在另外一个单独的外部文件中，文件以.css结尾 在&lt;head&gt;中使用&lt;link&gt;将文件链接到HTML文件中。 rel=&quot;stylesheet&quot; type=&quot;text/css&quot;是固定写法不可修改； &lt;link&gt;标签位置一般写在&lt;head&gt;标签之内。 三种链接方式优先级现在不考虑权值的情况。 就近原则，离被设元素越近优先级越高； 一般来说，外部式 &lt; 嵌入式 &lt; 内联式，因为在实际开发中一般都是&lt;link&gt;代码在&lt;style&gt;代码前面。 CSS3选择器选择器每一条css样式定义由两部分组成，形式如下： 123选择器{ 样式;} 类选择器语法： 1.类选器名称{css样式代码} 英文圆点开头； 类选器可任意取名，但不能取中文； 例如：将类选器标注为红色 1234567&lt;style type = \"text/css\"&gt;.classname{ color: red;}&lt;/style&gt;&lt;span class = \"classname\"&gt;类选器&lt;/span&gt; ID选择器语法： 1#ID选择器名称{css样式代码}; 使用ID选择器，必须给标签添加上id属性，为标签设置id=”ID名称”，而不是class=”类名称”。 ID选择符的前面是井号（#）号，而不是英文圆点（.）。 例如：将ID选择器标注为红色 1234567&lt;style type = \"text/css\"&gt;#idname{ color: red;}&lt;/style&gt;&lt;span id = \"idname\"&gt;ID选择器&lt;/span&gt; 类选择器和ID选择器的区别 ID选择器只能够在文档中使用一次，类选择器可以使用多次；如：可以出现多次&lt;span class = &quot;classname&quot;&gt;&lt;/span&gt;而只能出现一次&lt;span id = &quot;idname&quot;&gt;&lt;/span&gt; 类选择器可以使用词列表方式为同一个元素同时设定多种样式，ID选择器不可以使用词列表。如：为类选择器词列表使用两种样式 123456789&lt;style type = \"text/css\"&gt;.classname1{ color: red;}.classname2{ font-size: 12px;}&lt;/style&gt;&lt;span class = \"classname1 classname2\"&gt;类选择器词列表&lt;/span&gt; 子选择器&gt;（大于号）：用于选择指定标签元素的第一代子元素。 12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt;/*添加边框样式（粗细为1px， 颜色为红色的实线）*/.food&gt;li { border: 1px solid red;}&lt;/style&gt;&lt;ul class=\"food\"&gt;/*水果一个边框，框住了&lt;li&gt;&lt;/li&gt;之间的所有*/ &lt;li&gt;水果 &lt;ul&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;/*蔬菜一个边框*/ &lt;li&gt;蔬菜 &lt;ul&gt; &lt;li&gt;白菜&lt;/li&gt; &lt;li&gt;油菜&lt;/li&gt; &lt;li&gt;卷心菜&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 后代选择器&amp;nbsp;（空格）：（只是简单的空格，此处为了显示使用了空格符号）加入空格，用于选择指定标签元素下的后代所有元素。 12345678910111213141516171819202122232425262728293031&lt;style type=\"text/css\"&gt;/*添加边框样式（粗细为1px， 颜色为红色的实线）*/.food li { border: 1px solid red;}&lt;/style&gt;&lt;ul class=\"food\"&gt;/*水果一个边框，框住了&lt;li&gt;&lt;/li&gt;之间的所有*/ &lt;li&gt;水果 &lt;ul&gt; /*香蕉一个边框*/ &lt;li&gt;香蕉&lt;/li&gt; /*苹果一个边框*/ &lt;li&gt;苹果&lt;/li&gt; /*梨一个边框*/ &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;/*蔬菜一个边框*/ &lt;li&gt;蔬菜 &lt;ul&gt; /*白菜一个边框*/ &lt;li&gt;白菜&lt;/li&gt; /*油菜一个边框*/ &lt;li&gt;油菜&lt;/li&gt; /*卷心菜一个边框*/ &lt;li&gt;卷心菜&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 兄弟选择器 +:选择下一个兄弟元素 ~:选择下面所有兄弟元素 123456789/* 选择p标签后面的第一个兄弟span标签 */p+span{ color: red;}/* 选择p标签后面的所有兄弟span标签 */p~span{ color: green;} 通用选择器*（星号）：用于匹配HTML中所有的标签元素。 12345678910&lt;style type=\"text/css\"&gt;* { color: red; font-size: 20px;}&lt;/style&gt;/*所有标签下元素字体全部为红色，大小为20px*/&lt;h1&gt;一级标题&lt;/h1&gt;&lt;p&gt;文章&lt;/p&gt; 属性选择器 [属性名] 选择含有指定属性的元素 [属性名=属性值] 选择含有指定属性和指定属性值的元素 [属性名^=属性值] 选择含有指定属性和指定值开头的属性值的元素 [属性名$=属性值] 选择含有指定属性和指定值结尾的属性值的元素 [属性名=属性值] 选择含有指定属性和*包含**指定值的属性值的元素 属性值都可以加上引号&quot; 123456789101112131415161718192021222324/* 选择含有title属性的p标签 */p[title] { color: green;}/* 选择含有title=\"abc\"的p标签 */p[title=abc] { color: red;}/* 选择title属性值中以abc开头的p标签 */p[title^=abc] { color: orange;}/* 选择title属性值中以abc结尾的p标签 */p[title$=abc] { color: blue;}/* 选择title属性值中包含abc的p标签 */p[title*=abc] { color: yellow;} 伪类选择器伪类选择符允许给HTML不存在的标签 （标签的某种状态）设置样式，比如鼠标滑过状态： :hover：鼠标滑过 :active：鼠标点击 :first-child：第一个子元素 :last-child：最后一个子元素 :nth-child()：第n个子元素 :nth-child(n)：所有的子元素 :nth-child(2n)或:nth-child(even)：偶数位元素 :nth-child(2n+1)或:nth-child(odd)：奇数位元素 :first-of-type：每个类型的第一个子元素 :last-of-type：每个类型的最后一个子元素 :nth-of-type()：同类型的第n个子元素，特殊值与:nth-child()相同 :not()：否定，将符合条件的元素从选择器中去除 超链接独有伪类 :link：用来表示没访问过的链接（正常的链接） :visited：用来表示访问过的链接，由于隐私的问题，visited这个伪类只能修改链接的颜色 elem1&gt;elem2:x{}：elem1中先满足x伪类的元素，再满足类型是elem2。 1234567891011121314151617181920212223242526272829303132333435363738394041a:hover{css样式代码}/* ul中的第一个子元素，并且类型是li */ul&gt;li:first-child { color: red;}/* ul中的最后一个子元素，并且类型是li */ul&gt;li:last-child { color: green;}/* ul中的第二个子元素，并且类型是li */ul&gt;li:nth-child(2) { color: yellow;}/* ul中的所有li元素 */ul&gt;li:nth-child(n) { color: blue;}/* ul中的所有偶数位的li元素 */ul&gt;li:nth-child(2n) { /*2n或even */ color: orange;}/* ul中所有奇数位的li元素 */ul&gt;li:nth-child(2n+1) { /*2n+1或odd*/ color: red;}/* ul中li类型的第一个子元素 */ul&gt;li:first-of-type { color: yellow;}/* ul中去除最后一个子元素，并且类型是li */ul&gt;li:not(:last-child) { color: red;} 能兼容所有浏览器的”伪类选择符“只有a:hover。 伪元素 伪元素：表示页面中一些特殊的并不真实存在的元素（特殊的位置） 伪元素以::开头 1234567891011121314151617181920212223242526/* 将p标签中的第一个字母设置为红色 */p::first-letter{ color: red;}/* 将p标签中的第一行设置为绿色 */p::first-line{ color: green;}/* 将p标签中选中的元素设置为橘色 */p::selection{ color: orange;}/* 在div标签中的内容最前面加上【，并设置为蓝色 */div::before{ content: '【'; color: blue;}/* 在div标签中的内容的最后面加上】，并设置为蓝色 */div::after{ content: '】'; color: blue;} 分组选择器,（逗号）：为html中多个标签元素设置同一个样式。 12/*h1, span标签同时设置颜色为红色*/h1, span{color: red;} CSS3的继承，优先级和重要性样式的继承 继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代； 继承的设计是为了方便我们开发，利用继承就可以将一些通用的样式统一设置到祖先元素上，这样只需要设置一次即可让所有元素都具有这样的样式； 并不是所有的样式都会被继承，比如背景相关、布局相关等的样式都不会被继承。 选择器优先级 内联式插入样式 1,0,0,0 ID选择器 0,1,0,0 类选择器 0,0,1,0 标签选择器 0,0,0,1 通配符选择器 0,0,0,0 继承的样式 没有优先级 !important 选择器最高层级； 网页样式优先级：用户自定义样式&gt;网页制作者样式&gt;浏览器默认样式； 当设置了!important，权值高于用户自定义样式。 CSS3字体样式字体类型 字体类别，浏览器会自动使用该类别下的字体 serif 衬线字体 sans-serif 非衬线字体 monospace 等宽字体 font-family 可以同时指定多个字体，多个字体间用,隔开，在前面的字体优先使用 font-face 可以将服务器中的字体直接提供给用户使用，存在部分问题 加载速度 版权 字体格式 123456789101112/*设置字体为微软雅黑*/body{ font-family: \"Microsoft Yahei\";}@font-face { /* 自定义字体名字 */ font-family: 'xxx'; /* 指定路径和类型 */ /* 如需多个使用,分开 */ src: url('xxx') format('xxx');} 如果用户本地电脑没有安装设置的字体，则将显示浏览器默认字体。 字体大小1234/*设置字体为12px*/body{ font-size: 12px;} 字体粗细1234/*设置字体为粗体*/span{ font-weight: bold;} 字体版型123456/*设置字体版型：正常、斜体、倾斜的字体*/p{ font-style: normal; /*正常*/ font-style: italic; /*斜体，用于字体本身就有倾斜的格式*/ font-style: oblique; /*倾斜的字体，强制字体倾斜*/} 字体颜色 英文命令 12345678p{ color: red;}div{ border: 2px solid transparent; /*透明颜色*/} RGB颜色 123456p{ /*整数形式*/ color: rgb(133, 45, 200); /*分数形式*/ color: rgb(20%, 33%, 25%);} RGBA： 就是在RGB的基础上增加了一个A值，表示不透明度 需要四个值，前三个和RGB一样，第四个表示不透明度，1表示完全不透明，0表示完全透明，0.5半透明 十六进制颜色（普遍使用） 语法：#红色绿色蓝色 颜色浓度：00-ff 如果颜色两两重复，可以使用缩写 #aabbcc –&gt; #abc #aabbca 不能够缩写 HSL值、HSLA值 H：色相（0-360） S：饱和度，颜色的浓度（0%-100%） L：亮度，颜色的亮度（0%-100%） A：不透明度，（0-1） font样式缩写12345678910111213/*原版*/body{ font-style:italic; font-weight:bold; font-size:12px; line-height:1.5em; font-family:\"宋体\",sans-serif;}/*缩写版*/body{ font:italic bold 12px/1.5em \"宋体\",sans-serif;} 缩写版至少指定font-size和font-family； 缩写在font-size和line-height之间需要加/； 中文网站常用缩写格式 123body{ font: 12px/1.5em \"宋体\", sans-serif;} 图标字体 通过字体来使用图标 fontawesome 使用步骤 下载 https://fontawesome.com/ 解压 将css和webfonts移动到项目中，并且要位于同一级 将all.css引入网页中 使用方式 使用类名来指定使用图标字体，class=”fas fa-xxx”或class=”fab fa-xxx”12&lt;i class=\"fab fa-qq\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-bell\"&gt;&lt;/i&gt; 使用伪元素来设置图标字体 找到要设置图标的元素，通过before或after选中 在content中设置字体编码 设置字体格式 fab:font-family: ‘Font Awesome 5 Brands’; fas:font-family: ‘Font Awesome 5 Free’;font-weight: 900; 123456789101112li::before { content: '\\f42b'; font-family: 'Font Awesome 5 Brands'; /* font-weight: 400; */ /* 默认font-weight是400，所以可以忽略 */}li::after { content: '\\f44b'; font-family: 'Font Awesome 5 Free'; font-weight: 900;} 通过实体来使用图标字体:&amp;#x图标编码，同时也需要引入class=”fas”或class=”fab”;12&lt;li class=\"fab\"&gt;&amp;#xf42b;&lt;/li&gt;&lt;li class=\"fas\"&gt;&amp;#xf44b;&lt;/li&gt; CSS3文本样式文本修饰123456span{ text-decoration: none; /*默认标准文本*/ text-decoration: underline; /*文本下划线*/ text-decoration: overline; /*文本上一条线*/ text-decoration: line-through; /*穿过文本的一条线*/} 首行缩进123p{ text-indent: 2pm;} 2em的意思就是文字的2倍大小。 行高 行高指的是文字占有的实际高度 可以通过line-height来设置行高 可以直接指定一个大小（px，em） 也可以设置一个整数，这个整数就是字体大小的倍数 行高经常用来设置文字的行间距，行间距 = 行高 - 字体大小 字体框，字体框就是字体存在的格子，设置font-size实际上就是设置字体框的高度 行高会在字体框的上下平均分配 可以将行高设置为高度一样的值，可以使得单行文字在一个元素中垂直居中 123p{ line-height: 1.5em;} 字符间距 中文字、字母间距 123p{ letter-spacing: 20px;} 单词间距 123p{ word-spacing: 20px;} 水平对齐12345p{ text-align: center; /*居中*/ text-align: left; /*居左*/ text-align: right; /*居右*/} 元素垂直对齐 使用vertical-align 设置元素垂直对齐的方式 baseline 默认值，基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 直接指定长度值，如verticla-align: 10px; 设置文本省略号表示多余 white-space 设置网页如何处理空白 normal 正常 nowrap 不换行 pre 保留空白 需要满足四个条件（缺一不可） 设置一个宽度 width 设置white-space: nowrap，使得文本在一行上 设置超过宽度的部分隐藏 overflow: hidden 设置文本超出的部分显示省略号 text-overflow: ellipsis 长度值 像素 指的是显示器上的小点； 同样的像素大小可能在不同的设备下显示效果不同； 百分比 将属性值设置为相对于父元素属性的百分比 可以使得子元素随着父元素的改变而改变 1p{font-size:12px;line-height:130%} 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。 em 相对于本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。 但当给 font-size 设置单位为 em 时，此时计算的标准以父元素的 font-size 为基础； rem rem是相对于根元素（HTML元素）字体的font-size值 CSS3盒模型盒模型、盒子模型、框模型（box model） CSS将页面中的所有元素都设置成了一个矩形的盒子 将元素设置为矩形的盒子后，对页面的布局就变成了将不同的盒子摆放到不同位置 每一个盒子都由以下几个部分组成 内容区（content） 元素中的所有的子元素和文本内容都在内容区中排列 内容区的大小由width和height两个属性来设置 width设置内容区的宽度 height设置内容区的高度 内边距（padding） 边框（border） 边框属于合盒子边缘，边框里面属于盒子内部，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小 要设置边框，需要至少设置三个样式 边框的宽度（border-width） 边框的颜色（border-color） 边框的样式（border-style） 外边距（margin） 文档流 网页是一个多层的结构，一层摞着一层 通过CSS可以分别为每一层设置样式 作为用户来讲只能看到最顶层 在这些曾中，最底下的一层称为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列 对我们来说元素主要有两个状态 在文档流中 不在文档流中（脱离文档） 元素分类 块状元素&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;…&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 内联元素（行内元素）&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联块状元素&lt;img&gt;、&lt;input&gt; 块状元素设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。 1a{display:block;} 块级元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 元素高度在不设置的情况下，是内容的高度。 内联元素设置display:inline就是将元素显示为块级元素。如下代码就是将块状元素div转换为内联元素，从而使div元素具有内联元素特点。 123div{ display: inline;} 内联元素特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素设置 display: inline-block就是将元素显示为内联块状元素。 内联块状元素特点： 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 nonenone设置此元素不会被显示，当想要元素隐藏的时候可以使用此值。 123span{ display: none;} 宽度和高度一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 123456div{ width: 200px; padding: 20px; border: 1px solid red; margin: 10px;} 元素的实际长度为：10px+1px+20px+200px+20px+1px+10px=262px。在chrome浏览器下可查看元素盒模型，如下图： 背景色123div{ background-color: red; /*背景色为红色*/} 边框 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 123456789div{ /*缩写版*/ border: 2px solid red; /*完整版*/ border-width: 2px; border-style: solid; border-color: red;} border-width（边框宽度）：thin| medium| thick（不常用）像素（常用） border-style（边框样式）：dashed（虚线）、dotted（点线）、solid（实线）、double（双线） border-color（边框颜色）：十六进制色、英文色 单边框123456div{ border-top: 2px solid red; /*上边框*/ border-right: 2px solid red; /*右边框*/ border-bottom: 2px solid red; /*下边框*/ border-left: 2px solid red; /*左边框*/} 阴影 box-shadow 用来设置元素的阴影效果，阴影不会影响页面布局 1box-shadow: 0px 0px 50px rgba(0, 0, 0, 0.3); 第一个值 水平偏移量，设置阴影的水平位置，正值向右移动，负值向左移动。 第二个值 垂直偏移量，设置阴影的垂直位置，正值向下移动，负值向上移动。 第三个值 阴影的模糊半径，半径越大，效果越模糊 第四个值 阴影的颜色 轮廓线 outline用来设置元素的轮廓线，用法与border一模一样 与border的不同点：轮廓线不会影响到可见框的大小，不会影响页面布局 主要用在鼠标移动上，添加轮廓的效果 圆角123456789101112131415161718div{ /*左上 右上 右下 左下*/ /*顺时针方向*/ /*缩写版*/ border-radius: 20px 10px 15px 30px; /*完整版*/ border-top-left-radius: 20px; border-top-right-radius: 10px; border-bottom-right-radius: 15px; border-bottom-left-radius: 30px; /*如果四个圆角都相等*/ border-radius: 10px; /*如果左上右下为10px 右上左下为20px*/ border-radius: 10px 20px;} 显示圆形 1234567div{ width: 200px; height: 200px; border: 5px solid red; border-radius: 100px; /*像素值为宽度和长度的一半*/ border-radius: 50%; /*百分比显示*/} 内边距123456789101112131415161718div{ /*上右下左*/ /*顺时针*/ /*缩写版*/ padding: 20px 10px 15px 30px; /*完整版*/ padding-top: 20px; padding-right: 10px; padding-bottom: 15px; padding-left: 30px; /*如果上下左右都相等*/ padding: 10px; /*上下为10px，左右为20px*/ padding: 10px 20px;} 可见框 默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。 box-sizing: 可以用来设置盒子尺寸的计算方式（设置width和height的作用） content-box 默认值，宽度和高度用来设置内容区的大小 border-box 宽度和高度用来设置整个盒子可见框的大小，也就是直到边框 外边距 外边距不会影响盒子可见框的大小，但是会影响盒子的位置 一共有四个方向的外边距 margin-top：上外边距，设置一个正值，元素向下移动 margin-right：右外边距，默认情况下不会产生任何效果 margin-bottom：下外边距，设置一个正值，其下边的元素会向下移动 margin-left：左外边距，设置一个正值，元素会向右移动 默认情况下，如果我们设置的左和上外边距则会移动元素自身，而设置下和右外边距则会移动其他元素 margin会影响到盒子实际占用空间 123456789101112131415161718div{ /*上右下左*/ /*顺时针*/ /*缩写版*/ margin: 20px 10px 15px 30px; /*完整版*/ margin-top: 20px; margin-right: 10px; margin-bottom: 15px; margin-left: 30px; /*如果上下左右都相等*/ margin: 10px; /*上下为10px，左右为20px*/ margin: 10px 20px;} CSS3布局模型水平布局 元素在其父元素中水平方向的位置由以下几个属性共同决定 margin-left border-left padding-left width padding-right border-right margin-right 水平布局必须满足以上七个元素依次相加等于父元素内容区的宽度 如果不满足，则称为过度约束，等式自动调整 都没有设置auto，则会调整margin-right 如果width和margin同时设置auto，则会将margin设置为0，直接调整width 如果只有margin-left和margin-right设置为auto，且为正值，则会平均分配，如果为负值，则只会调整margin-right auto等级：width&gt;margin 垂直布局 子元素是在父元素的内容区排列的 如果子元素的大小超过了父元素，则子元素会从父元素溢出 使用overflow、overflow-x、overflow-y属性来设置父元素如何处理溢出 visible：默认值，子元素会从父元素中溢出，在父元素外部显示 hidden：溢出的内容被裁剪 scroll：生成两个滚动条 auto：根据需要生成滚动条 垂直外边距的折叠 相邻的垂直方向外边距会发生重叠现象 兄弟元素 当之间的相邻垂直外边距同号 之间的相邻垂直外边距会取两者之间的绝对值的较大值 当之间的相邻垂直外边距异号 之间的相邻垂直外边距会去两者之间的和 父子元素 父子元素之间相邻垂直外边距，子元素会传递给父元素 父子外边距的折叠会影响页面的布局，必须进行处理 行内元素的盒模型 行内元素不支持设置宽度和高度 行内元素设置的padding、border、margin都不会影响垂直方向的布局 display用来设置元素显示的类型 inline 将元素设置为行内元素 block 将元素设置为块元素 inline-block 将元素设置为行内块元素，既可以设置宽度和高度，又可以不独占一行 table 将元素设置成一个表格 none 元素不在页面中显示 visibility 用来设置元素的显示状态 visible 默认值，元素在页面中正常显示 hidden 元素在页面中隐藏，但是依然占据页面位置 css布局模型 流动模型（Flow） 浮动模型（Float） 层模型（Layer） 流动模型默认的网页布局模式。 特征： 块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，在默认状态下，块状元素的宽度都为100%； 在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型 通过浮动可以使一个元素向其父元素的左侧或右侧移动 使用float属性来设置元素的浮动 none 默认值，元素不浮动 left 元素向左浮动 right 元素向右浮动 元素设置浮动以后，水平布局的等式便不需要强制成立 元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，所以元素下边的还在文档流中的元素可以向上移动 浮动的特点 浮动元素会完全脱离文档流，不再占据文档流中的位置 设置浮动以后元素会向父元素的左侧或右侧移动 浮动元素默认不会从父元素中移出 浮动元素向左或向右移动时，不会超过它前边的其他浮动元素 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 浮动元素不会超过它上边的浮动的兄弟元素，最多和它在同一行 浮动元素的特点 浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果 脱离文档流后，宽度和高度都默认被内容撑开，并且不会独占一行 1234div{ float: left; float: right;} 高度塌陷问题和BFC 高度塌陷问题：在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动以后，其会完全脱离文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。父元素高度丢失以后，其下的元素会自动上移，导致页面混乱。 BFC（Block Formatting Context）：块级格式化环境 BFC是一个CSS中一个隐含的属性，一个元素开启BFC就会变成一个独立的布局区域。 开启BFC后的特点 开启BFC的元素不会被浮动元素所覆盖。 开启BFC的元素子元素和父元素外边距不会重叠。 开启BFC的元素可以包含浮动的子元素。 可以通过一些特殊的方式来开启元素的BFC 设置元素的浮动（不推荐） 将元素设置为行内块元素（不推荐） 将元素的overflow设置一个非visible的值，常用的方式是为元素设置overflow: hidden，开启其BFC。 clear 清除浮动元素对当前元素所产生的影响 left 清除左侧浮动元素对当前元素的影响 right 清除右侧浮动元素对当前元素的影响 both 清除两侧浮动元素对当前元素的影响（取两侧影响最大的那侧清除） 原理 设置清除浮动之后，浏览器会自动为元素添加一个上外边距以使得其位置不受到其他浮动元素的影响 使用::after和clear解决高度塌陷问题1234567891011121314151617181920div.outer { border: 10px red solid;}div.outer&gt;div.inner { width: 200px; height: 200px; background-color: #bfa; float: left; /* 子元素设置浮动，而父元素并未开启BFC，则会产生高度塌陷问题 */}div.outer::after { content: \"\"; display: block; clear: both; /* 在父元素中，通过::after伪元素添加一个空文本 而由于::after默认是行内元素，就算清除了前面浮动元素对页面布局的影响，不会出现在div.inner的下面，也只会出现在旁边，所以给其设置为block 然后再清除它前面浮动元素对页面布局的影响，则浏览器会给它设置一个与div.inner高度相同的上外边距，这样就可以将父元素的高度撑开了，并且高度和子元素所需要的高度相同 */} 使用::before解决父子元素垂直外边距重叠问题12345678910111213141516171819div.outer { width: 200px; height: 200px; background-color: #bfa;}div.outer&gt;div.inner{ width: 100px; height: 100px; background-color: orange; margin-top: 100px; /* 因为子元素的上外边距和父元素重叠，则设置子元素的上外边距会传递给父元素，这时候会整体移动，出现布局问题 */}div.outer::before{ content: \"\"; display: table; /* 在父子元素之间使用::before伪元素，将其隔开，则能够有效解决外边距重叠问题 */} 使用.clearfix同时解决高度塌陷和父子元素垂直外边距重叠问题123456.clearfix::before,.clearfix::after { content: \"\"; display: table; clear: both;} 定位 定位是一种更加高级的布局手段 通过定位可以将元素摆放到页面的任意位置 通过position属性来设置定位 static 默认值，元素是静止的没有开启定位 relative 开启元素的相对定位 absolute 开启元素的绝对定位 fixed 开启元素的固定定位 sticky 开启元素的粘滞定位 相对定位 当元素的position属性值设置为relative时，则开启了元素的相对定位 相对定位的特点 元素开启相对定位以后，如果不设置偏移量，元素不会发生任何变化 相对定位是参照元素在文档流中的位置进行定位的 相对定位会提升元素的层级 相对定位不会使元素脱离文档流 相对定位不会改变元素的性质 偏移量（offset） 当元素开启了定位以后，可以通过偏移量来设置元素的位置 top 定位元素和定位位置上边的距离 bottom 定位元素和定位位置下边的距离 left 定位元素和定位位置左边的距离 right 定位元素和定位位置的右侧距离 通常情况下，top和bottom只会使用一个来控制垂直位置，left和right只会使用一个来控制水平位置。 如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 12345div{ position: relative; /*相对定位*/ left: 100px; /*距离以前位置左侧100px*/ top: 50px; /*距离以前位置顶部50px*/} 绝对定位 当元素的position属性值设置为absolute时，则开启了元素的绝对定位 绝对定位的特点 开启绝对定位后，如果不设置偏移量元素的位置不会发生变化 开启绝对定位后，元素会从文档流中脱离 绝对定位会改变元素的性质，行内元素变成块元素，块元素的宽高被内容撑开 绝对定位会使元素提升一个层级 绝对定位元素是相对于其包含块进行定位的 包含块（containing block） 正常情况下，包含块就是离当前元素最近的祖先块元素 绝对定位下，包含块就是离当前元素最近的开启了定位的祖先块元素，如果所有祖先块元素都没有开启定位，则根元素就是它的包含块 html元素叫做根元素或者是初始包含块 如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 12345div{ position: absolute; /*绝对定位*/ left: 100px; /*距离左侧100px*/ top: 50px; /*距离顶部50px*/} 固定定位 当元素的position属性值设置为fixed时，则开启了元素的固定定位 大部分特点和绝对定位是一样的，只是固定定位永远参考于浏览器的视口进行定位 fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响。 12345div{ position: fixed; /*固定定位*/ right: 0px; /*距离网页窗口右侧0px*/ bottom: 0px; /*距离网页窗口底部0px*/} 粘滞定位 当元素的position属性设置为sticky时则开启了元素的粘滞定位 粘滞定位的特点和相对定位基本一样，不同的是粘滞定位可以在元素到达某个位置时将其固定 绝对定位与相对定位结合使用 参照定位的元素必须是相对定位元素的前辈元素： 12345&lt;div id=\"box1\"&gt;/*参照定位的元素*/ &lt;div id=\"box2\"&gt;相对参照元素进行定位&lt;/div&gt; /*相对定位元素*/&lt;/div&gt; 从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素了）。 参照定位的元素必须加入position:relative; 12345#box1{ width:200px; height:200px; position:relative; } 定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。 12345#box2{ position:absolute; top:20px; left:30px; } 这样box2就可以相对于父元素box1定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。 绝对定位元素的布局 当开启绝对定位后，水平方向的布局等式就需要添加left和right两个值，垂直方向就需要添加top和bottom left、right、top和bottom的默认值都是auto 如果发生过度约束 auto等级：width&gt;right&gt;left&gt;margin或height&gt;bottom&gt;top&gt;margin 检查有无auto 如果有，就按照auto等级调整 否则就调整right或bottom 元素的层级 对于开启了定位的元素，可以通过z-index属性来指定元素的层级 z-index需要一个整数作为参数，值越大元素层级越高，层级高的优先显示 如果元素层级一样，则优先显示靠下的元素 祖先元素的层级再高也不会盖住后代元素 背景 background-color: 设置背景颜色 background-image: 设置背景图片 通过设置url(“xxx”)，来选择背景图片 如果同时设定background-color和background-image，背景颜色会成为背景图片的背景色 如果背景图片尺寸小于元素，背景图片会将元素铺满 如果背景图片尺寸大于元素，背景图片多余部分会被裁剪 如果背景图片尺寸等于元素，背景图片正常显示 background-repeat: 设置背景图片重复方式 repeat 默认值，背景沿着x轴、y轴双方向重复 repeat-x 沿着x轴方向重复 repeat-y 沿着y轴方向重复 no-repeat 背景图片不重复 background-position: 设置背景图片位置 top、left、right、bottom、center：必须设置两个值，否则第二个值默认为center 偏移量（水平方向偏移量 垂直方向偏移量） background-size: 设置背景图片大小 两个值：宽度、高度，只写一个值的话，第二个值默认auto cover 图片比例不变，将元素铺满 contain 图片比例不变，将背景图片完整显示 background-origin: 设置背景图片的原点 padding-box 默认值，background-position从内边距处开始计算 content-box background-position从内容区开始计算 border-box background-position从边框区开始计算 background-clip: 设置背景范围 border-box 默认值，背景会出现在边框下 padding-box 背景出现在内边距和内容区下 content-box 背景出现在内容区 background-attachment: 背景图片是否跟着元素移动 scroll 默认值，背景图片会随着元素移动 fixed 背景固定在页面中，不会随元素移动 简写属性：background background-position/background-size: background-position必须写在background-size前面，并且用/隔开 background-origin background-clip: background-origin必须在background-clip前面flex弹性盒模型 flex属性123456789101112131415161718192021222324252627.box { background: blue; display: flex;}.box div { width: 200px; height: 200px;}.box1 { background: red;}.box2 { background: orange;}.box3 { background: green;}&lt;div class=\"box\"&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt;&lt;/div&gt; 三个块元素设置大小以及背景色，在父容器中添加flex。 技术点的解释： 设置display: flex属性可以把块级元素在一排显示。 flex需要添加在父元素上，改变子元素的排列顺序。 默认为从左往右依次排列,且和父元素左边没有间隙。 横轴排列方式1justify-content: flex-start| flex-end| center| space-between| space-around; flex-start：交叉轴的起点对齐； flex-end：右对齐； center： 居中； space-between：两端对齐，项目之间的间隔都相等； space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 纵轴排列方式1align-items: flex-start| flex-end| center| baseline| stretch; flex-start：默认值，左对齐； flex-end：交叉轴的终点对齐； center： 交叉轴的中点对齐； baseline：项目的第一行文字的基线对齐； stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 flex占比 给子元素设置flex属性,可以设置子元素相对于父元素的占比。 flex属性的值只能是正整数,表示占比多少。 给子元素设置了flex之后,其宽度属性会失效。 水平居中显示行内元素123.center{ text-align: center;} 块状元素——定宽块状元素1234div{ width: 200px; /*定宽，不可缺*/ margin: 20px auto; /*上下为20px，左右auto*/} 已知宽高实现盒子水平垂直居中123456789101112131415.box { border: 1px solid #00ee00; height: 300px; position: relative;}.box1 { width: 200px; height: 200px; border: 1px solid red; position: absolute; top: 50%; left: 50%; margin:-100px 0 0 -100px;} 利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。 子元素设置上和左偏移的值都为50%，是元素的左上角在父元素中心点的位置。效果： 然后再用margin给上和左都给负的自身宽高的一半,就能达到垂直水平居中的效果。 不知宽高实现盒子水平垂直居中12345678910111213.box { border: 1px solid #00ee00; height: 300px; position: relative;}.box1 { border: 1px solid red; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} 利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。 子元素设置上和左偏移的值都为50%。 然后再用css3属性translate位移,给上和左都位移-50%距离，就能达到垂直水平居中的效果。","link":"/2020/06/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Flask学习笔记","text":"Flask是目前最流行的Python Web框架之一 初识Flask搭建开发环境安装pip和Pipenv123$ pip --version //检查pip是否安装$ pip install pipenv //使用pip安装Pipenv$ pipenv install //为当前项目创建虚拟环境 如果pip install过程中下载很慢，则修改Pifile中的源为url = &quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot; 安装Flask12$ pipenv install flask //安装flask$ pipenv update flask //更新flask Hello，Flask！切换到当前目录1$ cd demos/hello 创建程序实例12from flask import Flaskapp = Flask(__name__) 注册路由123456789101112131415161718# 简单注册路由@app.route('/')def index(): return '&lt;h1&gt;Hello, World!&lt;/h1&gt;'# 为视图绑定多个URL@app.route('/hi')@app.route('/hello')def say_hello(): return '&lt;h1&gt;Hello, Flask!&lt;/h1&gt;'# 动态URL@app.route('/greet', defaults={'name': 'Programmer'}) # 设置默认值@app.route('/greet/&lt;name&gt;')def greet(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name 启动开发服务器 通过命令行 1$ flask run PyCharm配置 Target type：Module name（必选） Target：（必填） Additional options：–host=127.0.0.1 –port=5000（可填） FLASK_ENV：development（必填） Working directory：&lt;工作目录&gt;（必填） URL与端点 使用http://127.0.0.1:1234/test/addi进行访问 如果动态路由没有设置默认值 12345@app.route('/test/&lt;additional&gt;')def test(additional): # 第一个additional是test的形参，第二个additional是URL传入进来的 part_url = url_for('test', additional=additional) # /test/addi all_url = url_for('test', additional=additional, _external=True) # http://127.0.0.1:1234/test/addi 如果动态路由设置了默认值12345@app.route('/test', defaults={'additional': 'default'})@app.route('/test/&lt;additional&gt;')def test(additional): part_url = url_for('test') # /test all_url = url_for('test', _external=True) # http://127.0.0.1:1234/test url_for是用来获取要使用某一方法的最简洁URL 模板模板基本用法三种定界符 语句 1{% ... %} 表达式 1{{ ... }} 注释 1{# ... #} 语句结束标签 if-else 12345{% if ... %} //if 语句{% else ... %} //else 语句{% endif %} for 123{% for i in ... %} //for语句{% endfor %} 模板语法 变量名 说明 loop.index 当前迭代数（从1开始计数） loop.index0 当前迭代数（从0开始计数） loop.revindex 当前反向迭代数（从1开始计数） loop.revindex0 当前反向迭代数（从0开始计数） loop.first 如果是第一个元素，则为True loop.last 如果是最后一个元素，则为True loop.previtem 上一个迭代的条目 loop.nextitem 下一个迭代的条目 loop.length 序列包含的元素数量 渲染模板使用Flask提供的渲染函数render_template()1234from flask import Flask, render_template@app.route('/watchlist')def watchlist(): return render_template('watchlist.html', user=user, movies=movies) 模板辅助工具上下文 自定义上下文变量 123456{% set navigation = [{'/', 'Home'}, {'/about', 'About'}] %}{% set navigation %} &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt;{% endset %} 内置上下文变量 变量 说明 config 当前的配置对象 request 当前的请求对象，在已激活的请求环境下可用 session 当前的会话对象，在已激活的请求环境下可用 g 与请求绑定的全局变量，在已激活的请求环境下可用 自定义上下文 设置模板全局变量 1234567891011# 1. 注册模板上下文处理函数@app.context_processordef inject_foo(): foo = 'I am foo.' return dict(foo=foo) # 2. 添加现有函数app.context_processor(inject_foo) # 3.使用lambda简化app.context_processor(lambda: dict(foo='I am foo.')) 全局对象 内置全局函数 函数 说明 range([start, ]stop[, step]) 和Python中的range()用法相同 lipsum(n = 5, html = True, min = 20, max = 100 生成随机文本 dict(**item) 和Python中的dict()用法相同 url_for() 用于生成URL的函数 get_flashed_message() 用于获取flash消息的函数 自定义全局函数 1234567# 1. 注册全局函数@app.template_global()def bar(): return 'I am bar.'# 2. 添加全局函数@app.add_template_global(bar) 过滤器 用法 1234567# 1. 对变量进行过滤{{ name|title }}# 2. 对模板进行过滤{% filter upper %} This text becomes uppercase.{% endfilter %} 内置过滤器 过滤器 说明 default(value, default_value=u”, boolean=False) 设置默认值，默认值作为参数传入，别名为d escape(s) 转义HTML文本，别名为e first(seq) 返回序列的第一个元素 last(seq) 返回序列的最后一个元素 length(object) 返回变量的长度 random(seq) 返回序列中的随机元素 safe(value) 将变量值标记为安全，避免转义 trim(value) 清除变量值前后的空格 max(value, case_sensitive = False, attribute = None 返回序列中的最大值 min(value, case_sensitive = False, attribute = None 返回序列中的最小值 unique(value, case_sensitive = False, attribute = None 返回序列中的不重复的值 striptags(value) 清除变量值内的HTML标签 urlize(value, trim_url_limit = None, nofollow = False, target = None, rel = None 将URL文本转换成可单击的HTML链接 wordcount(s) 计算单词数量 tojson(value, indent = None) 将变量值转换为JSON格式 truncate(s, length = 255, killwords = False, end=’…’, leeway=None 截断字符串，常用于显示文章摘要，length参数设置截断的长度，killwords参数设置是否截断单词，end参数设置结尾的符号 自定义过滤器 12345678# 1. 注册自定义过滤器from flask import Markup@app.template_filter()def musical(s): return s + Markup(' &amp;#9835;')# 2. 添加方式注册app.add_template_filter(musical) 在使用过滤器时，竖线符号左边的值，是过滤器函数的第一个值，其他参数可以通过添加括号传入 测试器 用法 12345{% if age is number %} {{ age * 365 }}{% else %} 无效数字{% endif %} 内置测试器 测试器 说明 callable(object) 判断对象是否可被调用 defined(value) 判断变量是否已定义 undefined(value) 判断变量是否未定义 none(value) 判断变量是否为None number(value) 判断变量是否是数字 string(value) 判断变量是否是字符串 sequence(value) 判断变量是否是序列，比如字符串、列表、元组 iterable(value) 判断变量是否可迭代 mapping(value) 判断变量是否是匹配对象，比如字典 sameas(value, other) 判断变量与other是否指向相同的内存地址 自定义测试器 123456789# 1. 注册自定义测试器@app.template_test()def baz(n): if n == 'baz': return True return False# 2. 添加注册自定义测试器app.add_template_test(baz) 在使用测试器时，is的左侧是测试器函数的第一个参数(value)，其他参数可以添加括号传入，也可以在右侧使用空格连接，以sameas为例： 123{% if foo is sameas(bar) %}# 等同于{% if foo is sameas bar %} 模板环境对象 添加自定义全局对象 1app.jinja_env.globals['bar'] = bar 添加自定义过滤器 1app.jinja_env.filters['smiling'] = smiling 添加自定义测试器 1app.jinja_env.tests['baz'] = baz 模板结构组织局部模板 提示：为了和普通模板区分开，局部模板的命名通常以一个下划线开始 用法 12# 在任意位置，使用以下代码插入局部模板{% include '_xxx.html' %} 宏 简单示例 1234567{% macro qux(amount=1) %} {% if amount == 1 -%} I am qux. {%- elif amount &gt; 1 -%} We are quxs. {%- endif %}{% endmacro %} 用法 123{% from 'macros.html' import qux %}# ...{{ qux(amount = 5) }} 默认情况下，包含（include）一个局部模板会传递当前上下文到局部模板中，但是导入（import）不会。如果想要导入（import）也传递当前上下文，则需要显式地使用with context。 1{% from 'macros.html' import qux with context %} 模板继承 编写基模板，通常命名为base.html或layout.html 12{% block head %}{% endblock %} 编写子模板 覆盖内容 1234{% extend 'base.html' %}{% block head %}{# ... #}{% endblock %} 追加内容 1234{% extend 'base.html' %}{{ super() }}{# ... #}{% endblock %} 模板进阶实践空白控制 渲染时自动去除右边空格 1{% -%} 渲染时自动去除左边空格 1{%- %} 利用环境对象 1234# 删除Jinja2语句后的第一个空行app.jinja_env.trim_blocks = True# 删除Jinja2语句所在行之前的空格和制表符app.jinja_env.lstrip_block = True 需要注意：宏内的空白控制行为不受trim_blocks和lstrip_blocks属性控制，需要手动控制 加载静态文件 默认将静态文件存储在与主脚本同级目录的static文件夹中 通过url_for('static', filename='avatar.jpg')获取到/static/avatar.jpg 添加Favicon 添加文件favicon.ico到static目录下 在&lt;head&gt;部分添加一个&lt;link&gt;元素 1&lt;link rel=\"icon\" type=\"image/x-icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\"&gt; 使用宏加载静态资源 123456789101112{% macro static_file(type, filename_or_url, local=True) %} {% if local -%} {% set filename_or_url = url_for('static', filename=filename_or_url) %} {%- endif %} {% if type == 'css' -%} &lt;link rel=\"stylesheet\" href=\"{{ filename_or_url }}\" type=\"text/css\"&gt; {%- elif type == 'js' -%} &lt;script type=\"text/javascript\" src=\"{{ filename_or_url }}\"&gt;&lt;/script&gt; {%- elif type == 'icon' -%} &lt;link rel=\"icon\" href=\"{{ filename_or_url }}\"&gt; {%- endif %}{% endmacro %} 1234# 1. 加载静态资源static_file('css', '/css/bootstrap.min.css')# 2. 从CDN加载资源static_file('css', 'https://.../css/bootstrap.min.css', local=False) 消息闪现 使用flash()函数闪现 1flash('flash message.') 使用get_flashed_messages()在模板中获取消息 123{% for message in get_flashed_messages() %} &lt;div class=\"alert\"&gt;{{ message }}&lt;/div&gt;{% endfor %} 自定义错误页面1234from flask import Flask, render_template@app.errorhandler(404)def page_not_found(e): return render_template('errors/404.html'), 404 JavaScript和CSS中的Jinja2 定义为JavaScript变量 定义 1&lt;span data-id=\"{{ user.id }}\" data-username=\"{{ user.username }}\"&gt;{{ user.username }}&lt;/span&gt; 使用 123element.dataset.usernameelement.getAttribute('data-username')$element.data('username') 定义为CSS变量 定义 123456&lt;style&gt;:root { --theme-color: {{ theme_color }}; --background-url: {{ url_for('static', filename='background.jpg') }}}&lt;/style&gt; 使用 1234567#foo { color: var(--theme-color);} #bar { background: var(--background-url);}","link":"/2021/01/23/Flask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"初入MVC--从前端到后台","text":"愿你熬得过万丈孤独，藏得下星辰大海 客户端技术编程一、主要完成内容 使用网页模板进行自定义设计和填充对应内容 添加日间模式和夜间模式切换功能 添加网站部分小功能，例如返回顶部和小部件缓慢切出等功能 二、主要功能实现网站整体布局 整体采用垂直布局的方式，从上至下依次是顶部导航栏、主要图片和内容的轮播图、主要信息部分、主要内容部分、特征部分、图片轮播图部分、视频展示部分、底部信息部分 在整体下面，每个子部分使用宽度撑满的策略，使其能够依次排列 顶部菜单模块 菜单使用弹性盒模型display: flex，使得菜单排列在一行，并且控制每个的标签的padding属性，使其整齐排列 网站名称使用行内盒模型display: inline-block;，并设置white-space: nowrap;，使其不换行，配合padding完成位置布局 展示图片的gallery模块 通过JavaScript调整其图片的class为owl-item cloned active或owl-item cloned，配合类选择器选择active来设置样式 动画效果通过设置transform和transition来实现动画效果 三、额外功能实现日间模式和夜间模式切换 简要描述实现过程 在右下角设置一个切换按钮，样式设置成太阳和月亮的切换，太阳代表切换成日间模式，月亮代表切换成夜间模式 使用JavaScript获取到此时的模式，并设置在点击的时候实现切换功能 如果切换成夜间模式，主要将背景切换成黑色，并且设置一定的不透明度，再将字体设置为白色，形成一个高对比，然后将切换按钮的图片修改为太阳图标 如果切换成日间模式，主要将样式修改成默认样式，再将切换按钮的图片修改为月亮图标 HTML部分 12345&lt;section class=\"right-nav\" id=\"right-nav\"&gt; &lt;div class=\"black\" id=\"black\"&gt; &lt;img src=\"img/night.png\" alt=\"夜间模式\"&gt; &lt;/div&gt;&lt;/section&gt; CSS部分 12345.right-nav .black img{ border-radius: 50%; width: 30px; height: 30px;} JavaScript部分 点击事件 123$(\"#black\").click(function () { //功能实现...} 获取模式信息 12//获取对应模式信息，夜间模式或日间模式var s = $(\"[alt$='间模式']\").attr(\"alt\"); 设置对应模式样式 夜间模式 1234567891011$('body').css(\"background-color\", \"black\") //设置背景颜色为黑色$('body').css(\"opacity\", \"0.7\") //设置不透明度$('body').css(\"-moz-opacity\", \"0.7\")$('body').css(\"filter\", \"alpha(opacity=50)\") //设置滤镜$('body').append(\"&lt;style&gt;::selection {background-color: #d8d5da;color: #fff;}&lt;/style&gt;\") //设置选中的背景样式$('.mb-10,.pb-30,p,li,a,span.lnr').css(\"color\", \"white\") //给对应字体设置颜色$('span.lnr-arrow-up,span.lnr-arrow-down').css(\"color\", \"#222\") //给箭头设置颜色$('.project-area,.info-content,.single-feature,.gallery-area').css(\"background-color\", \"black\") //给对应模块设置背景样式$('.header-btn').css(\"background-color\", \"transparent\") //设置对应按钮背景颜色透明$('.info-content').append(\"&lt;style&gt;.info-area .info-content::after{background-color: black}&lt;/style&gt;\") //给对应元素添加样式$('.active-works-carousel .owl-dots .owl-dot.active').css(\"background\", \"#777777;\") //设置背景颜色 日间模式 12345678910$('body').css(\"background-color\", \"\"); //设置为默认背景颜色$('body').css(\"opacity\", \"\") //取消不透明$('body').css(\"-moz-opacity\", \"\")$('body').css(\"filter\", \"\") //取消滤镜//给对应部件设置样式$('body').append(\"&lt;style&gt;::selection {background-color: #b01afe;color: #fff;}&lt;/style&gt;\")$('.mb-10,.pb-30,p,li,a,span.lnr').css(\"color\", \"\")$('.project-area,.info-content,.single-feature,.gallery-area').css(\"background-color\", \"\")$('.header-btn').css(\"background-color\", \"white\")$('.info-content').append(\"&lt;style&gt;.info-area .info-content::after{background-color: white}&lt;/style&gt;\") 切换功能 夜间模式 1234$(\"[alt='夜间模式']\").attr({ \"src\": \"img/sum.png\", \"alt\": \"日间模式\"}); 日间模式 1234$(\"[alt='日间模式']\").attr({ \"src\": \"img/night.png\", \"alt\": \"夜间模式\"}); 缓慢切入 简要描述实现过程 使用选择器，选择到对应的元素后，设置transition: 5s，将如果某个属性发生改变，则在5s内缓慢改变 通过JavaScript实现在加载的时候，修改这个元素的位置，配合css的设置，则实现了缓慢切入的动画 css部分 12345678.right-nav { position: fixed; bottom: 20px; right: -30px; z-index: 999; transition: 5s; //设置transition后，right从—30px变化到20px的过程总共花费5s cursor: pointer;} Javascript部分 123window.onload = function () { document.getElementById(\"right-nav\").style.right = \"20px\";} 四、主要结果截图 日间模式和夜间模式的切换 夜间模式 日间模式 右下角的功能按钮 整体实现效果 JavaScript编程一、主要完成内容 随机生成4位的字母和数字组合的验证码 实现通过滑块进行图片验证 二、主要功能实现随机产生一个四位验证码 makeCode()：随机产生一个四位验证码的主要函数 1234567891011//产生一个四位验证码function makeCode() { string = \"\" //初始验证码为空 var code = document.getElementById(\"code-main\") //DOM获取元素 code.onclick = makeCode //设置code点击事件 refresh.onclick = makeCode //设置refresh点击事件 for(let i = 0; i &lt; 4; ++i) { //总共产生4位 string += createChar() //每次添加一个随机位 } code.innerHTML = string //修改HTML数据} createChar()：随机产生一个字符a-z,A-Z,0-9 12345678910111213function createChar() { var num = Math.round(Math.random()) == 0 //随机确定是字母还是数字 if(num == true) { //如果是数字，则返回0-9 return Math.round(Math.random()*9) } else { //如果是字母 var char = String.fromCharCode(65 + Math.round(Math.random() * 25)) //随机产生一个字母 if(Math.round(Math.random()) == 0) { //确定大小写 return char.toLowerCase() //返回小写 } return char //返回大写 }} 验证四位验证码是否正确 testCode()：进行验证码验证 12345678910function testCode() { // console.log(\"success\") console.log(char_code.value) if (char_code.value == string) { //如果输入与随机产生相同 alert(\"字符验证码验证成功！\") } else { //如果不同 alert(\"字符验证码验证失败！\") } location.reload()} 随机产生一个图片缺口 selectSection()：随机挑选图片中的一部分 1234567891011121314function selectSection() { var img = document.getElementById(\"img\") //DOM获取id为img的元素 var height_string = img.getAttribute(\"height\") //获取元素的高度 var img_height = height_string.substring(0, height_string.indexOf(\"px\")) //获取实际像素值 var img_url = img.getAttribute(\"src\") //获取图片地址 //设置成功位置的位置 success_section.style.top = success_position_y + \"px\" success_section.style.left = success_position_x + \"px\" //进行按钮位置微调 section.style.top = success_position_y - img_height - 6 + \"px\" //获取图片缺省部分 section.style.background = \"url(\" + img_url + \") -\" + success_position_x + \"px -\" + success_position_y + \"px/auto \" + img_height + \"px\"} 随机产生图片 randomImage()：随机产生图片 1234567function randomImage() { var img = document.getElementById(\"img\") //获取图片元素 var num = Math.ceil(Math.random()*5) + 1; //随机产生图片序号 img_num = (img_num + num)%5 + 2 //适配本地图片序号 var img_src = \"./img/img\"+ img_num +\".png\" //生成对应地址 img.setAttribute(\"src\",img_src) //修改图片} 通过滑块进行图片验证 buttonDown(e)：图片button点击事件 123456789101112function buttonDown(e) { //清除样式 button.style.transition = \"\" background.style.transition = \"\" //获取button开始位置 var e = e || window.event || e.which; start_button_position = e.clientX document.onmousemove = buttonMove //设置鼠标移动事件 document.onmouseup = buttonUp //设置鼠标松开事件} buttonMove(e)：图片button移动事件 123456789function buttonMove(e) { var button_move = e.clientX //获取移动的位置 //获取移动的长度 move_length = moveLength(button_move - start_button_position, 0, max_length) //修改移动过程中的样式 button.style.left = move_length + \"px\" background.style.width = move_length + 20 + \"px\"} buttonUp()：图片button鼠标松开 123456789101112131415function buttonUp() { var abs = Math.abs(move_length - success_length) //获取移动的距离和需要移动的距离的差值 if (abs &gt;= 5) { //如果超过5px的偏差，则失败，重新调整按钮位置 button.style.left = \"\" background.style.width = \"\" //控制其缓慢移动 button.style.transition = \"left 0.8s linear\" background.style.transition = \"width 0.8s linear\" } else { //否则就验证成功 successMove() } //取消事件，重新开始 document.onmousemove = null document.onmouseup = null} moveLength(length, min, max)：返回一个符合规范的移动长度 12345678function moveLength(length, min, max) { if (length &lt; min) { //如果小于最低要求，则返回最低要求 return min } else if (length &gt; max) { //如果超过最高要求，则返回最高要求 return max } return length //正常返回} successMove()：成功对齐执行函数 1234567891011121314151617function successMove() { success = true //设置状态为true text.innerHTML = \"解锁成功\" //修改HTML内容 background.style.backgroundColor = \"lightgreen\" //修改背景颜色 // icon.className = \"fas fa-thumbs-up\" icon.className = \"icon iconfont iconicon_xuanzhong\" //更换图标 icon.style.color = \"green\" //设置颜色 //取消对应事件 button.onmousedown = null document.onmousemove = null //延时100ms后弹出结果，并在确认后刷新 setTimeout(function() { alert(\"图片解锁成功！\") location.reload() }, 100)} 三、额外功能实现自动获取焦点 简要描述：设置输入框的autofocus属性为autofocus 代码实现 1&lt;input type=\"text\" id=\"char-input\" autofocus=\"autofocus\"&gt; 监听回车 简要描述：在输入完毕后可以直接在输入框中输入回车，则进行验证字符验证码 代码实现 1234567char_code.onkeypress = listenDownfunction listenDown(e) { var e = e || window.event || e.which; if(e.keyCode == 13) { //如果是回车，进行验证码验证 testCode() }} 四、主要样式实现 简要描述 布局问题：整体大概划分了两个部分，左边字符验证部分和右边的图片验证部分，主要使用的是设置一个主div，和两个子div，然后两个子div进行float: left浮动起来，形成两个同时水平排列 矢量图标问题：这次实现过程中，不仅使用了阿里的矢量图标库，也使用了iconfont的矢量图标库，两者既有差别又有很多相似之处 主要实现部分 布局问题 123456789101112.char-code { //字符验证部分 float: left; margin: 100px; width: 270px;}.captcha { //图片验证部分 float: left; width: 400px; margin: 0px auto; margin-top: 50px;} 矢量图标问题 阿里矢量图标 1234&lt;link rel=\"stylesheet\" href=\"ali-font/iconfont.css\"&gt; &lt;!-- 引入阿里库 --&gt;&lt;div class=\"icon iconfont iconicon-doubleright-line\" id=\"icon\"&gt;&lt;/div&gt; &lt;!-- 右移动图标 --&gt;&lt;div class=\"icon iconfont iconicon_xuanzhong\" id=\"icon\"&gt;&lt;/div&gt; &lt;!-- 成功图标 --&gt; iconfont矢量图标 12345&lt;!-- 引入iconfont库 --&gt;&lt;link rel=\"stylesheet\" href=\"./fa/css/all.min.css\"&gt;&lt;link rel=\"stylesheet\" href=\"./iconfont/iconfont.css\"&gt;&lt;i class=\"fas fa-sync fa-spin\" id=\"refresh\"&gt;&lt;/i&gt; &lt;!-- 刷新图标 --&gt; 五、主要结果截图 主界面 字符验证成功界面 图片验证成功界面 GuestBookSystem一、主要完成内容 使用ASP.NET MVC + Code First技术完成留言本系统 具有普通用户和管理员用户两个角色 普通用户具有登录，注册，发布个人留言，阅读全部留言，显示个人留言等功能 管理员用户具有登录，注册，审核留言，删除留言，阅读留言等功能 并且该留言本系统具有用户审核等功能 二、主要功能实现非特定角色功能 登录功能 登录验证简要逻辑 首先在视图中进行输入账号密码，在前端首先进行验证 如果前端输入出现异常，则前端进行简要格式验证，并将错误信息返还给用户，进行提示 对应的输入使用Razor，以便能够简单验证输入的数据 保存错误信息使用@Html.ValidationSummary()，添加在页面中，但是进行隐藏，前端不直接显示，而通过JavaScript的alert进行简易的弹窗 如果通过前端简要验证，则通过POST传输到后台Account/Login，后台进行数据库查询 如果没有这条记录，则提示登录失败的信息，并返回登录视图，给用户重新登录 如果查询到对应记录，则辨别是管理员还是普通用户，如果是管理员则跳转到Admin/Index，如果是普通用户则跳转到User/AllWords，再进行后续操作 登录功能前端代码 12345678910111213141516171819@model GuestBookSystem.Models.User@{ ViewBag.Title = \"Login\"; Layout = \"~/Views/Shared/_LayoutAccount.cshtml\";}@using (Html.BeginForm(\"Login\", \"Account\", new { ReturnUrl = \"\" }, FormMethod.Post)){ &lt;div class=\"user\"&gt; @Html.TextBoxFor(a =&gt; a.Name, new { @placeholder = \"用户名\" }) &lt;/div&gt; &lt;div class=\"password\"&gt; @Html.TextBoxFor(a =&gt; a.Password, new { @placeholder = \"密码\", @type = \"password\" }) &lt;/div&gt; &lt;div class=\"submit\"&gt; &lt;input type=\"submit\" value=\"登录\" id=\"submit\"&gt; &lt;/div&gt; &lt;span hidden id=\"hidden\"&gt;@Html.ValidationSummary()&lt;/span&gt;} 登录验证后台代码 123456789101112131415161718//在数据库中查找对应账号密码var dbUser = db.Users.Where( a =&gt; a.Name == user.Name &amp;&amp; a.Password == user.Password).FirstOrDefault();if (dbUser != null) //如果能找到对应账号密码{ ViewBag.STATE = true; //记录登录状态 if (dbUser.SRole.ToString() == &quot;管理员&quot;) //如果是管理员 { Session[&quot;UserId&quot;] = dbUser.UserId; //记录UserId return RedirectToAction(&quot;Index&quot;, &quot;Admin&quot;); //跳转Admin/Index } else if (dbUser.SRole.ToString() == &quot;普通用户&quot;) //如果是普通用户 { Session[&quot;UserId&quot;] = dbUser.UserId; return RedirectToAction(&quot;AllWords&quot;, &quot;User&quot;); //跳转User/AllWords }} 注册功能 注册功能简要逻辑 首先在视图中进行输入账号密码，在前端首先进行验证 如果前端输入出现异常，则前端进行简要格式验证，并将错误信息返还给用户，进行提示 实现提示逻辑和登录功能相似，都是使用@Html.ValidationSummary() 如果通过前端简要验证，则通过POST传输到后台Account/Register，后台进行注册验证 如果注册失败，则提示注册失败的信息，并返回注册视图，给用户重新注册 如果注册成功，则跳转到登录界面，便于用户的登录 注册功能前端代码 12345678910111213141516171819202122232425@using (Html.BeginForm(\"Register\", \"Account\", FormMethod.Post)){ &lt;div class=\"email\"&gt; @Html.TextBoxFor(a =&gt; a.Email, new { @placeholder = \"注册邮箱\" }) &lt;/div&gt; &lt;div class=\"name\"&gt; @Html.TextBoxFor(a =&gt; a.Name, new { @placeholder = \"注册用户名\" }) &lt;/div&gt; &lt;div class=\"password\"&gt; @Html.TextBoxFor(a =&gt; a.Password, new { @placeholder = \"注册密码\" }) &lt;/div&gt; &lt;div class=\"srole\"&gt; &lt;span class=\"text\"&gt; 注册角色: &lt;/span&gt; &lt;select id=\"SRole\" name=\"SRole\"&gt; &lt;option value=\"0\"&gt;管理员&lt;/option&gt; &lt;option value=\"1\" selected&gt;普通用户&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"submit\"&gt; &lt;input type=\"submit\" value=\"注册\" id=\"submit\"&gt; &lt;/div&gt; &lt;span hidden id=\"hidden\"&gt;@Html.ValidationSummary()&lt;/span&gt;} 注册功能后台代码 1234567891011[HttpPost]public ActionResult Register(User user){ if (ModelState.IsValid) //如果状态通过 { db.Users.Add(user); //在数据库中添加这个记录 db.SaveChanges(); //保存数据库 return RedirectToAction(&quot;Login&quot;); //跳转到/Login } return View(); //如果不通过，则返回注册视图} 主页阅读留言功能 留言功能实现逻辑 通过数据库进行查询状态为通过的留言，并更加创建时间进行倒序，并将数据传送给前端 前端通过@foreach，进行遍历输出对应字段 留言功能前端代码 12345678910@foreach (var gb in Model){ &lt;tr&gt; &lt;td&gt; &lt;span class=\"username\"&gt;@gb.User.Name :&lt;/span&gt; &lt;span class=\"context\"&gt;@gb.Content&lt;/span&gt; &lt;span class=\"date\"&gt;@gb.CreatedOn&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt;} 留言功能后台代码 1234567GBSDBContext db = new GBSDBContext(); //数据库// GET: GuestBookpublic ActionResult Index(){ var gb = db.Guestbooks.Where(a =&gt; a.isPass == true); //如果查询到状态为通过的留言 return View(gb.OrderByDescending(a=&gt;a.CreatedOn).ToList()); //则根据创建留言时间进行倒序} 普通用户功能 发布个人留言 发布个人留言简要逻辑 首先在前端进行个人留言的输入，如果出现格式错误，则会在前端就进行提醒，使用的逻辑还是@Html.ValidationSummary()，和前面相同 前端验证格式成功之后，通过POST方式，提交到后台的User/CreateWords，再进行处理 后台首先获取登录的ID，自动添加到留言本中，再将留言本的这条记录保存到数据库中，最后将个人留言界面返回给用户 发布个人留言前端代码 12345678910111213141516&lt;form action=\"/User/CreateWords\" method=\"post\"&gt; &lt;table class=\"second\"&gt; &lt;tr&gt; &lt;td&gt;标题：&lt;/td&gt; &lt;td&gt;@Html.TextBoxFor(g =&gt; g.Title, new { @autocomplete = \"off\", autofocus=\"autofocus\"})&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容：&lt;/td&gt; &lt;td&gt;@Html.TextAreaFor(g =&gt; g.Content, new { cols = 50, rows = 10 })&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td class=\"button\"&gt;&lt;input type=\"submit\" value=\"发布\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 发布个人留言后台代码 12345678if (ModelState.IsValid){ gb.User = db.Users.Where(a =&gt; a.UserId == UserId).FirstOrDefault(); //找到登录用户的ID，自动添加到留言本中 //gb.CreatedOn = System.DateTime.Now; db.Guestbooks.Add(gb); //在数据库中添加这条记录 db.SaveChanges(); //保存数据库 return RedirectToAction(&quot;MyWords&quot;); //跳转到/User/MyWords，显示个人留言} 显示个人留言 显示个人留言简要逻辑 后台通过登录用户的ID，在数据库中进行查找，查找到的结果通过创建时间逆序传递给前端 前端通过foreach进行遍历，将结果进行输出，特别地是在是否通过审核这一栏，进行if判断，如果通过则显示审核通过，否则显示正在审核 显示个人留言前端代码 1234567891011121314151617@foreach (var gb in Model){&lt;tr class=\"clearfix\"&gt; &lt;td&gt;&lt;span&gt;@gb.User.Name&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.CreatedOn&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Title&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Content&lt;/span&gt;&lt;/td&gt; &lt;td&gt; &lt;span class=\"pass\"&gt; @if (gb.isPass == true) {@Html.DisplayName(\"审核通过\") } else {@Html.DisplayName(\"正在审核\")} &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;} 显示个人留言后台代码 12var gb = db.Guestbooks.Where(a =&gt; a.User.UserId == UserId);return View(gb.OrderByDescending(a=&gt;a.CreatedOn).ToList()); 显示全部留言 显示全部留言简要逻辑 使用的整体逻辑和主界面阅读全部留言类似 特别地是在普通用户界面可以较为详细地查看留言，例如可以多查看到留言本标题 显示全部留言前端代码 123456789@foreach (var gb in Model){&lt;tr class=\"clearfix\"&gt; &lt;td&gt;&lt;span&gt;@gb.User.Name&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.CreatedOn&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Title&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Content&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;} 显示全部留言后台代码 12345public ActionResult AllWords(){ var gb = db.Guestbooks.Where(a =&gt; a.isPass == true); return View(gb.OrderByDescending(a=&gt;a.CreatedOn).ToList());} 管理员功能 审核留言 审核留言简要逻辑 后台首先获取到所有未通过审核的留言，将这些留言按照创建时间逆序传递给前端 前端将这些留言进行显示，并在每一条留言后面都添加一个审核通过的按钮 点击审核通过的按钮，则跳转到Admin/CheckMessageToFind，进行确认是否通过审核 再显示确认通过审核的界面，让管理员用户进行进一步操作 审核留言前端代码 显示未通过审核的留言 12345678910@foreach (var gb in Model){&lt;tr class=\"clearfix\"&gt; &lt;td&gt;&lt;span&gt;@gb.User.Name&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.CreatedOn&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Title&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Content&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span class=\"button\"&gt;@Html.ActionLink(\"审核通过\", \"CheckMessageToFind\", new { id = gb.GuestbookId })&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;} 确认通过审核 1234567891011121314151617181920212223@using (Html.BeginForm()){ &lt;div class=\"info\"&gt; &lt;table class=\"confirmed\"&gt; &lt;tr&gt; &lt;td&gt;确认是否通过&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;留言人：@Model.User.Name&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容：@Model.Content&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;时间：@Model.CreatedOn&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"button\"&gt;&lt;input type=\"submit\" value=\"确认\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; @Html.ActionLink(\"X\", \"CheckIndex\", new { }, new { @class = \"close\" }) &lt;/div&gt;} 审核留言后台代码 显示所有未通过审核的留言 123456public ActionResult CheckIndex(){ GetUser(); var gb = db.Guestbooks.Where(a =&gt; a.isPass == false); //获取没有通过审核的留言本 return View(gb.OrderByDescending(a=&gt;a.CreatedOn).ToList()); //通过创建时间逆序，并传递给前端} 确认是否通过审核 123456public ActionResult CheckMessageToFind(int id){ GetUser(); var gb = db.Guestbooks.Find(id); //查找到留言本ID return View(gb); //返回确认界面，给管理员用户确认是否通过审核} 如果审核通过 123456789[HttpPost, ActionName(&quot;CheckMessageToFind&quot;)]public ActionResult CheckMessage(int id){ GetUser(); var gb = db.Guestbooks.Find(id); //获取留言本ID gb.isPass = true; //将通过状态设置为true db.SaveChanges(); //保存数据库 return RedirectToAction(&quot;CheckIndex&quot;); //返回到Admin/CheckIndex，显示还未通过的留言} 删除留言 删除留言简要逻辑 后台首先获取到所有可删除的留言，将这些留言按照创建时间逆序传递给前端 前端将这些留言进行显示，并在每一条留言后面都添加一个删除留言的按钮 点击删除留言的按钮，则跳转到`Admin/Delete，进行确认是否删除 再显示确认删除的界面，让管理员用户进行进一步操作 删除留言前端代码 显示所有能删除的留言 12345678910@foreach (var gb in Model){&lt;tr class=\"clearfix\"&gt; &lt;td&gt;&lt;span&gt;@gb.User.Name&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.CreatedOn&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Title&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;@gb.Content&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span class=\"button\"&gt;@Html.ActionLink(\"删除留言\", \"Delete\", new { id = gb.GuestbookId })&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;} 确认是否删除留言 1234567891011121314151617181920212223@using (Html.BeginForm()){ &lt;div class=\"info\"&gt; &lt;table class=\"confirmed\"&gt; &lt;tr&gt; &lt;td&gt;确认是否删除&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;留言人：@Model.User.Name&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容：@Model.Content&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;时间：@Model.CreatedOn&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"button\"&gt;&lt;input type=\"submit\" value=\"确认\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; @Html.ActionLink(\"X\",\"Index\", new { }, new { @class=\"close\"}) &lt;/div&gt;} 删除留言后台代码 显示所有可删除的留言 12345public ActionResult Index(){ GetUser(); return View(db.Guestbooks.OrderByDescending(db =&gt; db.CreatedOn).ToList()); //通过创建时间逆序，传递给前端} 是否删除留言 123456public ActionResult Delete(int id){ GetUser(); var gb = db.Guestbooks.Find(id); //找到这条留言的ID return View(gb); //返回确认删除的视图} 确认删除这条留言 123456789[HttpPost, ActionName(&quot;Delete&quot;)]public ActionResult DeleteConfirmed(int id){ GetUser(); var gb = db.Guestbooks.Find(id); //找到这条留言的ID db.Guestbooks.Remove(gb); //在数据库中删除这条留言 db.SaveChanges(); //保存数据库 return RedirectToAction(&quot;Index&quot;); //返回/Admin/Index} 三、部分额外功能超长文本省略处理 功能实现简要描述 超长文本进行省略处理，鼠标移动上去显示全文 在CSS中设置空白处理方式：不换行，超出部分隐藏和文本超出使用省略号 在JavaScript中获取到所有span标签，遍历所有的span如果其中文字的宽度大于元素的宽度，则将该span标签的title属性设置为其内容 CSS部分（以主页留言本显示为例） 12345678910.guestbook .main .list tr td span { display: inline-block; padding-left: 20px; height: 50px; text-align: center; line-height: 50px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;} JavaScript部分 123456var spans = document.getElementsByTagName(\"span\")for (let i = 0; i &lt; spans.length; ++i) { if (spans[i].scrollWidth &gt; spans[i].offsetWidth) { spans[i].setAttribute(\"title\", spans[i].innerText) }} 用户验证 功能实现简要描述 必须登录后才可以使用普通用户和管理员操作 在普通用户控制器User和管理员控制器Admin中添加[Authorize] 如果在未登录的情况下，直接使用User或Admin中的方法，则会重定向到登录界面 只有在对应角色登录后，才可以使用对应角色的方法 在使用完对应角色的方法后，可以使用退出功能，进行账号退出 功能实现后台代码 Web.confi设置为表单验证 1234&lt;authentication mode=&quot;Forms&quot;&gt; &lt;forms loginUrl=&quot;/Account/LoginFirst&quot; defaultUrl=&quot;/&quot; timeout=&quot;30&quot; path=&quot;/&quot;&gt; &lt;/forms&gt;&lt;/authentication&gt; Login方法中进行设置 12345FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(1, user.UserId.ToString(), DateTime.Now, DateTime.Now.AddMinutes(30), false, user.SRole.ToString());string hashTicket = FormsAuthentication.Encrypt(ticket);HttpCookie cookie = new HttpCookie(FormsAuthentication.FormsCookieName, hashTicket);cookie.HttpOnly = true;Response.Cookies.Add(cookie); 在普通用户控制器User和管理员控制器Admin中添加[Authorize]，使其进行验证 账号退出 12345public ActionResult Logout(){ FormsAuthentication.SignOut(); return RedirectToAction(&quot;Index&quot;, &quot;GuestBook&quot;);} 四、其他实现数据库实现 数据库上下文 123456public class GBSDBContext : DbContext{ public DbSet&lt;Guestbook&gt; Guestbooks { get; set; } public DbSet&lt;Admin&gt; Admins { get; set; } public DbSet&lt;User&gt; Users { get; set; }} 用户角色信息 123456789101112131415161718public class User{ public int UserId { get; set; } [System.ComponentModel.DataAnnotations.Required(ErrorMessage = &quot;邮箱不能为空&quot;)] [EmailAddress(ErrorMessage =&quot;邮箱格式不对&quot;)] public string Email { get; set; } [Unique] [System.ComponentModel.DataAnnotations.Required(ErrorMessage = &quot;用户名不能为空&quot;)] [MaxLength(10,ErrorMessage =&quot;用户名长度不能大于10个字符&quot;)] public string Name { get; set; } [System.ComponentModel.DataAnnotations.Required(ErrorMessage = &quot;密码不能为空&quot;)] [MaxLength(20, ErrorMessage = &quot;密码长度不能大于20个字符&quot;)] [MinLength(6,ErrorMessage =&quot;密码长度不能少于6个字符&quot;)] [DataType(DataType.Password)] public string Password { get; set; } public SystemRole SRole { get; set; } public virtual ICollection&lt;Guestbook&gt; Guestbooks { get; set; }} 留言本信息 1234567891011121314public class Guestbook{ public int GuestbookId { get; set; } [Required(ErrorMessage = &quot;留言标题不能为空&quot;)] [MaxLength(20, ErrorMessage = &quot;留言标题不超过20个字符&quot;)] public string Title { get; set; } //留言标题 [Required(ErrorMessage = &quot;留言内容不能为空&quot;)] [MinLength(1, ErrorMessage = &quot;留言内容不少于1个字符&quot;)] public string Content { get; set; } //留言内容 [DatabaseGenerated(DatabaseGeneratedOption.Computed)] public DateTime CreatedOn { get; set; } //创建日期时间 public bool isPass { get; set; } public virtual User User { get; set; }} 默认模板实现 账号登录、注册部分 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;@ViewBag.Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"~/Content/guestbook-index.css\"&gt; &lt;link href=\"~/IconFont/fa/css/all.min.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"~/IconFont/iconfont/iconfont.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;img class=\"img\" src=\"~/Image/bg.jpg\"&gt; &lt;div class=\"guestbook clearfix\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"back\"&gt; &lt;a href=\"/GuestBook/Index\"&gt; &lt;i class=\"fas fa-angle-double-left\"&gt;&lt;/i&gt; &lt;span&gt;返回&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"title\"&gt; &lt;span&gt;欢迎访问留言本&lt;/span&gt; &lt;/div&gt; &lt;div class=\"buttons\"&gt; &lt;div class=\"button login\"&gt; &lt;span&gt;@Html.ActionLink(\"用户登录\", \"Login\", \"Account\")&lt;/span&gt; &lt;/div&gt; &lt;div class=\"button register\"&gt; &lt;span&gt;@Html.ActionLink(\"用户注册\", \"Register\", \"Account\")&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"main-login\"&gt; @RenderBody() &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; 2020-@DateTime.Now.Year RuanXinWei版权所有&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 后台部分 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;@ViewBag.NAME 后台&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/Content/admin-index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;welcome&quot;&gt; 欢迎 @ViewBag.NAME ! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main clearfix&quot;&gt; @RenderBody() &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 五、主要结果截图 留言本主页面 注册页面 登录页面 用户页面 管理员页面 确认信息页面 小结​ 首先，我很庆幸选择了学习.NET架构，因为通过学习这门课程，让我了解到了前端和后台可以通过MVC进行配合。就在今年完成数据库课程设计的时候，我就十分迷茫，不知道该如何将前端和后台进行配合，虽然最后使用了PHP进行后台操作数据库完成了课程设计，但是深刻体会到了用字符串保存SQL，网站整体样式的设计等痛苦。 ​ 但是在我学习完.NET架构后，学会了用Code-first来操作数据库，这种方式不仅能够避免在编写SQL的时候出现字符错误，还能够很好地进行保存，修改等一系列操作，通过类操作数据库的好处就从而体现出来了。还有在为网站设计整体风格的时候，通过添加布局页，一方面大大减少了代码的冗余量，另一方面也提高了开发的效率。 ​ 总的来说，从最开始的客户端技术编程到最后的MVC编程，让我慢慢从只会做一些简单的样式到能够实现一些具有实际意义的样式，让我从只会做样式到能够配合后台来实现一个实际的网站。到最后，回顾这门课的学习，虽然过程真的很苦，每天熬夜干代码，但是收获到的结果也是十分丰厚的。","link":"/2020/12/10/%E5%88%9D%E5%85%A5MVC-%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E5%8F%B0/"},{"title":"Java基础知识","text":"Java基础知识 1. Java 基本功 1.1. Java 入门（基础概念与常识） 1.1.1. Java 语言有哪些特点? 1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答 1.1.2.1. JVM 1.1.2.2. JDK 和 JRE 1.1.3. Oracle JDK 和 OpenJDK 的对比 1.1.4. Java 和 C++的区别? 1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同? 1.1.6. Java 应用程序与小程序之间有哪些差别? 1.1.7. import java 和 javax 有什么区别？ 1.1.8. 为什么说 Java 语言“编译与解释并存”？ 1.2. Java 语法 1.2.1. 字符型常量和字符串常量的区别? 1.2.2. 关于注释？ 1.2.3. 标识符和关键字的区别是什么？ 1.2.4. Java中有哪些常见的关键字？ 1.2.5. 自增自减运算符 1.2.6. continue、break、和return的区别是什么？ 1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？ 1.2.8. ==和equals的区别 1.2.9. hashCode()与 equals() 1.3. 基本数据类型 1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？ 1.3.2. 自动装箱与拆箱 1.3.3. 8种基本类型的包装类和常量池 1.4. 方法（函数） 1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么? 1.4.2. 为什么 Java 中只有值传递？ 1.4.3. 重载和重写的区别 1.4.3.1. 重载 1.4.3.2. 重写 1.4.4. 深拷贝 vs 浅拷贝 1.4.5. 方法的四种类型 2. Java 面向对象 2.1. 类和对象 2.1.1. 面向对象和面向过程的区别 2.1.2. 构造器 Constructor 是否可被 override? 2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用 2.1.4. 成员变量与局部变量的区别有哪些？ 2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同? 2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么? 2.1.7. 构造方法有哪些特性？ 2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是? 2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同? 2.2. 面向对象三大特征 2.2.1. 封装 2.2.2. 继承 2.2.3. 多态 2.3. 修饰符 2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的? 2.3.2. 静态方法和实例方法有何不同 2.3.3. 常见关键字总结:static,final,this,super 2.4. 接口和抽象类 2.4.1. 接口和抽象类的区别是什么？ 2.5. 其它重要知识点 2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的? 2.5.2. Object 类的常见方法总结 2.5.3. == 与 equals(重要) 2.5.4. hashCode 与 equals (重要) 2.5.4.1. hashCode（）介绍 2.5.4.2. 为什么要有 hashCode 2.5.4.3. hashCode（）与 equals（）的相关规定 2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？ 2.5.6. 获取用键盘输入常用的两种方法 3. Java 核心技术 3.1. 集合 3.1.1. Collections 工具类和 Arrays 工具类常见方法总结 3.2. 异常 3.2.1. Java 异常类层次结构图 3.2.2. Throwable 类常用方法 3.2.3. try-catch-finally 3.2.4. 使用 try-with-resources 来代替try-catch-finally 3.3. 多线程 3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么? 3.3.2. 线程有哪些基本状态? 3.4. 文件与 I\\O 流 3.4.1. Java 中 IO 流分为几种? 3.4.1.1. 既然有了字节流,为什么还要有字符流? 3.4.1.2. BIO,NIO,AIO 有什么区别? 4. 参考 5. 声明 1. Java 基本功1.1. Java 入门（基础概念与常识）1.1.1. Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 修正（参见： issue#544）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread 1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答1.1.2.1. JVMJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。 Java 程序从源代码到运行一般有下面 3 步： 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结： Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 1.1.2.2. JDK 和 JREJDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 1.1.3. Oracle JDK 和 OpenJDK 的对比可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。 对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案： 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？ 答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence 。 OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题； 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能； Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。 1.1.4. Java 和 C++的区别?我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理机制，不需要程序员手动释放无用内存 在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束。但是，Java 语言中没有结束符这一概念。 这是一个值得深度思考的问题，具体原因推荐看这篇文章： https://blog.csdn.net/sszgg2006/article/details/49148189 1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 1.1.6. Java 应用程序与小程序之间有哪些差别?简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 1.1.7. import java 和 javax 有什么区别？刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。 所以，实际上 java 和 javax 没有区别。这都是一个名字。 1.1.8. 为什么说 Java 语言“编译与解释并存”？高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。 1.2. Java 语法1.2.1. 字符型常量和字符串常量的区别? 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节) java 编程思想第四版：2.2.2 节 1.2.2. 关于注释？Java 中的注释有三种： 单行注释 多行注释 文档注释。 在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。 《Clean Code》这本书明确指出： 代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。 举个例子： 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可 12// check to see if the employee is eligible for full benefitsif ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65)) 应替换为 1if (employee.isEligibleForFullBenefits()) 1.2.3. 标识符和关键字的区别是什么？在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。 1.2.4. Java中有哪些常见的关键字？ 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 1.2.5. 自增自减运算符在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。 ++和–运算符可以放在操作数之前，也可以放在操作数之后，当运算符放在操作数之前时，先自增/减，再赋值；当运算符放在操作数之后时，先赋值，再自增/减。例如，当“b=++a”时，先自增（自己增加 1），再赋值（赋值给 b）；当“b=a++”时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。 1.2.6. continue、break、和return的区别是什么？在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词： continue ：指跳出当前的这一次循环，继续下一次循环。 break ：指跳出整个循环体，继续执行循环下面的语句。 return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。 更多关于类型擦除的问题，可以查看这篇文章：《Java泛型类型擦除以及类型擦除带来的问题》 。 1234567891011List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(12);//这里直接添加会报错list.add(\"a\");Class&lt;? extends List&gt; clazz = list.getClass();Method add = clazz.getDeclaredMethod(\"add\", Object.class);//但是通过反射添加，是可以的add.invoke(list, \"kl\");System.out.println(list) 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。 1.泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; }} 如何实例化泛型类： 1Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 2.泛型接口 ： 123public interface Generator&lt;T&gt; { public T method();} 实现泛型接口，不指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{ @Override public T method() { return null; }} 实现泛型接口，指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;{ @Override public String method() { return \"hello\"; }} 3.泛型方法 ： 1234567public static &lt; E &gt; void printArray( E[] inputArray ){ for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } 使用： 12345// 创建不同类型数组： Integer, Double 和 CharacterInteger[] intArray = { 1, 2, 3 };String[] stringArray = { \"Hello\", \"World\" };printArray( intArray ); printArray( stringArray ); 常用的通配符为： T，E，K，V，？ ？ 表示不确定的 java 类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element 更多关于Java 泛型中的通配符可以查看这篇文章：《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》 1.2.8. ==和equals的区别== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals() : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。 Object类equals()方法： 123public boolean equals(Object obj) { return (this == obj);} equals() 方法存在两种使用情况： 情况 1：类没有覆盖 equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 Object类equals()方法。 情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 { public static void main(String[] args) { String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) { // true System.out.println(\"true\"); } }} 说明： String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 String类equals()方法： 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 1.2.9. hashCode()与 equals()面试官可能会问你：“你重写过 hashcode 和 equals么，为什么重写 equals 时必须重写 hashCode 方法？” 1)hashCode()介绍: hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 1public native int hashCode(); 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 2)为什么要有 hashCode？ 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 3)为什么重写 equals 时必须重写 hashCode 方法？ 如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？ 在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。 因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode。 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 更多关于 hashcode() 和 equals() 的内容可以查看：Java hashCode() 和 equals()的若干问题解答 1.3. 基本数据类型1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？Java中有8种基本数据类型，分别为： 6种数字类型 ：byte、short、int、long、float、double 1种字符类型：char 1中布尔型：boolean。 这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 基本类型 位数 字节 默认值 int 32 4 0 short 16 2 0 long 64 8 0L byte 8 1 0 char 16 2 ‘u0000’ float 32 4 0f double 64 8 0d boolean 1 false 对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素。 注意： Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析： char a = 'h'char :单引号，String a = &quot;hello&quot; :双引号 1.3.2. 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 更多内容见：深入剖析 Java 中的装箱和拆箱 1.3.3. 8种基本类型的包装类和常量池Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？（参见issue/461）性能和资源之间的权衡。 123public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE);} 123456789private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); } } 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。** 123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false Integer 缓存源代码： 12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/ public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 应用场景： Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。 123Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);//输出 false Integer 比较更丰富的一个例子: 12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println(\"i1=i2 \" + (i1 == i2));System.out.println(\"i1=i2+i3 \" + (i1 == i2 + i3));System.out.println(\"i1=i4 \" + (i1 == i4));System.out.println(\"i4=i5 \" + (i4 == i5));System.out.println(\"i4=i5+i6 \" + (i4 == i5 + i6)); System.out.println(\"40=i5+i6 \" + (40 == i5 + i6)); 结果： 123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 解释： 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 1.4. 方法（函数）1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！ 1.4.2. 为什么 Java 中只有值传递？首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。 Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 123456789101112131415161718public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);}public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);} 结果： 1234a = 20b = 10num1 = 10num2 = 20 解析： 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);}public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0;} 结果： 1210 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 12345678910111213141516171819public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName()); } public static void swap(Student x, Student y) { Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName()); }} 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 交换之后： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结 Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 参考： 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节 1.4.3. 重载和重写的区别 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法 1.4.3.1. 重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 下面是《Java 核心技术》对重载这个概念的介绍： 综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。 1.4.3.2. 重写重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变 暖心的 Guide 哥最后再来个图标总结一下！ 区别点 重载方法 重写方法 发生范围 同一个类 子类 中 参数列表 必须修改 一定不能修改 返回类型 可修改 一定不能修改 异常 可修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 1.4.4. 深拷贝 vs 浅拷贝 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 1.4.5. 方法的四种类型1、无参数无返回值的方法 1234// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)public void f1() { System.out.println(\"无参数无返回值的方法\");} 2、有参数无返回值的方法 1234567/*** 有参数无返回值的方法* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开*/public void f2(int a, String b, int c) { System.out.println(a + \"--&gt;\" + b + \"--&gt;\" + c);} 3、有返回值无参数的方法 12345// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）public int f3() { System.out.println(\"有返回值无参数的方法\"); return 2;} 4、有返回值有参数的方法 1234// 有返回值有参数的方法public int f4(int a, int b) { return a * b;} 5、return 在无返回值方法的特殊使用 1234567// return在无返回值方法的特殊使用public void f5(int a) { if (a&gt;10) { return;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行} System.out.println(a);} 2. Java 面向对象2.1. 类和对象2.1.1. 面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 参见 issue : 面向过程 ：面向过程性能比面向对象高？？ 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。 2.1.2. 构造器 Constructor 是否可被 override?Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 2.1.4. 成员变量与局部变量的区别有哪些？ 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 2.1.7. 构造方法有哪些特性？ 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。 2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?帮助子类做初始化工作。 2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同?对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 2.2. 面向对象三大特征2.2.1. 封装封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。 123456789101112131415161718192021222324public class Student { private int id;//id属性私有化 private String name;//name属性私有化 //获取id的方法 public int getId() { return id; } //设置id的方法 public void setId(int id) { this.id = id; } //获取name的方法 public String getName() { return name; } //设置name的方法 public void setName(String name) { this.name = name; }} 2.2.2. 继承不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 2.2.3. 多态多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 对象类型不可变，引用类型可变； 方法具有多态性，属性不具有多态性； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 2.3. 修饰符2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的?由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 2.3.2. 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。 2.3.3. 常见关键字总结:static,final,this,super详见笔主的这篇文章: https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super 2.4. 接口和抽象类2.4.1. 接口和抽象类的区别是什么？ 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注： 在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:https://github.com/Snailclimb/JavaGuide/issues/146。 jdk9 的接口被允许定义私有方法 。 总结一下 jdk7~jdk9 Java 中接口概念的变化（相关阅读）： 在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk8 的时候接口可以有默认方法和静态方法功能。 Jdk 9 在接口中引入了私有方法和私有静态方法。 2.5. 其它重要知识点2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。 补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value; 而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 1234567891011121314abstract class AbstractStringBuilder implements Appendable, CharSequence { /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; AbstractStringBuilder(int capacity) { value = new char[capacity]; }} 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 2.5.2. Object 类的常见方法总结Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法： 123456789101112131415161718192021public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作 2.5.3. == 与 equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 { public static void main(String[] args) { String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) { // true System.out.println(\"true\"); } }} 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 2.5.4. hashCode 与 equals (重要)面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？” 2.5.4.1. hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 2.5.4.2. 为什么要有 hashCode我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 2.5.4.3. hashCode（）与 equals（）的相关规定 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个对象分别调用 equals 方法都返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 推荐阅读：Java hashCode() 和 equals()的若干问题解答 2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。 2.5.6. 获取用键盘输入常用的两种方法方法 1：通过 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法 2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in));String s = input.readLine(); 3. Java 核心技术3.1. 集合3.1.1. Collections 工具类和 Arrays 工具类常见方法总结详见笔主的这篇文章: https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md 3.2. 异常3.2.1. Java 异常类层次结构图 图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/ 图片来自：https://chercher.tech/java-programming/exceptions-java 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。 注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。 3.2.2. Throwable 类常用方法 public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息 3.2.3. try-catch-finally try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch 块： 用于处理 try 捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在以下 4 种特殊情况下，finally 块不会被执行： 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行 程序所在的线程死亡。 关闭 CPU。 下面这部分内容来自 issue:https://github.com/Snailclimb/JavaGuide/issues/190。 注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下： 1234567891011public class Test { public static int f(int value) { try { return value * value; } finally { if (value == 2) { return 0; } } }} 如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。 3.2.4. 使用 try-with-resources 来代替try-catch-finally《Effecitve Java》中明确指出： 面对必须要关闭的资源，我们总是应该优先使用try-with-resources而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。 Java 中类似于InputStream、OutputStream 、Scanner 、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下： 1234567891011121314//读取文本文件的内容Scanner scanner = null;try { scanner = new Scanner(new File(\"D://read.txt\")); while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException e) { e.printStackTrace();} finally { if (scanner != null) { scanner.close(); }} 使用Java 7之后的 try-with-resources 语句改造上面的代码: 1234567try (Scanner scanner = new Scanner(new File(\"test.txt\"))) { while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException fnfe) { fnfe.printStackTrace();} 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。 通过使用分号分隔，可以在try-with-resources块中声明多个资源： 3.3. 多线程3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 3.3.2. 线程有哪些基本状态?Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）： 由上图可以看出： 线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。 操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。 3.4. 文件与 I\\O 流3.4.1. Java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： 3.4.1.1. 既然有了字节流,为什么还要有字符流?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 3.4.1.2. BIO,NIO,AIO 有什么区别? BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 4. 参考 https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre https://www.educba.com/oracle-vs-openjdk/ https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top 5. 声明 本篇文章仅用于学习保存，并非本人原创，欢迎关注原作者 如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。 《Java 面试突击》: 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本公众号后台回复 “Java 面试突击” 即可免费领取！ Java 工程师必备学习资源: 一些 Java 工程师常用学习资源公众号后台回复关键字 “1” 即可免费无套路获取。","link":"/2021/02/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MVC","slug":"MVC","link":"/categories/MVC/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}